{
  "articles": [
    {
      "html": "<table class=\"d-block\" data-paste-markdown-skip>\n  <tbody class=\"d-block\">\n    <tr class=\"d-block\">\n      <td class=\"d-block comment-body markdown-body  js-comment-body\">\n          <h2>一、why Koa</h2>\n<ol>\n<li><code>Koa</code>是由<code>Express</code>原班人马打造，但是相较于<code>Express</code>的大而全，<code>Koa</code>是小而精的。<code>Koa</code>没有绑定很多的框架以及插件，更容易让我们进行扩展，包括现在较为流行的<code>EggJS</code> and <code>ThinkJS</code>都是基于<code>Koa</code>开发的。</li>\n<li><code>Koa</code>避免了Express中间件基于callback形式的调用，它使用了我们JS新版本特性，<code>Koa1</code>中间件借助于我们的<code>co</code> and <code>generator</code>特性，<code>Koa2</code>借助了<code>Promise</code> and <code>async await</code>特性，更好的进行流程控制以及catch我们的错误。</li>\n<li><code>Koa</code>提供了<code>Context</code>对象，实际上是对我们node中<code>request</code> and <code>response</code>对象的封装，我们不需要很多的手动处理我们的<code>request</code> and <code>response</code>对象。<code>Context</code>是贯穿我们整个请求的过程，我们可以中间件需要传递参数挂在到<code>Context</code>对象上。（栗子：我们可以将用户信息挂在它上面，通过<code>ctx.state.user</code>进行操作。）</li>\n<li><code>Koa</code>的中间件执行机制：<code>洋葱圈模型</code>。它不是按顺序执行的，多个中间件会形成一个<code>先进后出</code>的栈结构，当前中间件掌握下一个中间件的执行权，对于流程控制以及后置处理逻辑的实现非常有效。</li>\n</ol>\n<h2>二、Koa2与Koa1的比较</h2>\n<ol>\n<li>中间件的管理方式：<code>Koa1</code>借助<code>co</code> and <code>generator</code>管理我们的中间件，<code>Koa2</code>借助<code>async await</code>（async函数返回的是<code>Promise</code>对象）管理我们的中间件。</li>\n<li><code>context</code>对象获取：<code>Koa1</code>通过<code>this</code>对象（<code>this.req</code>,<code>this.res</code>）获取，<code>Koa2</code>通过<code>ctx</code>参数（<code>ctx.req</code>, <code>ctx.res</code>）获取。</li>\n<li><code>Koa2</code>的轮子多且成熟，生态比<code>Koa1</code>丰富。</li>\n</ol>\n<h2>三、举个栗子，剖析源码</h2>\n<h3>1. 栗子</h3>\n<p><a target=\"_blank\" rel=\"noopener noreferrer\" href=\"https://camo.githubusercontent.com/b4390ee94df94f96610941a183d70ea13aaba2ae/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323031392f706e672f3637363630302f313537373735353539393033312d61303663626330622d386333612d343166622d623939662d3962666266643964333561312e706e6723616c69676e3d6c65667426646973706c61793d696e6c696e65266865696768743d353133266e616d653d696d6167652e706e67266f726967696e4865696768743d353133266f726967696e57696474683d3438332673697a653d3533373736267374617475733d646f6e65267374796c653d6e6f6e652677696474683d343833\"><img src=\"https://camo.githubusercontent.com/b4390ee94df94f96610941a183d70ea13aaba2ae/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323031392f706e672f3637363630302f313537373735353539393033312d61303663626330622d386333612d343166622d623939662d3962666266643964333561312e706e6723616c69676e3d6c65667426646973706c61793d696e6c696e65266865696768743d353133266e616d653d696d6167652e706e67266f726967696e4865696768743d353133266f726967696e57696474683d3438332673697a653d3533373736267374617475733d646f6e65267374796c653d6e6f6e652677696474683d343833\" alt=\"image.png\" data-canonical-src=\"https://cdn.nlark.com/yuque/0/2019/png/676600/1577755599031-a06cbc0b-8c3a-41fb-b99f-9bfbfd9d35a1.png#align=left&display=inline&height=513&name=image.png&originHeight=513&originWidth=483&size=53776&status=done&style=none&width=483\" style=\"max-width:100%;\"></a><br>\n这段代码呢，通过<code>listen</code>方法创建了我们的http服务器，端口是<code>3000</code>。并且通过<code>use</code>方法传入了三个<code>koa</code>中间件, 并且<code>console</code>出我们的执行结果。</p>\n<h3>2. 从<code>listen</code>方法说起</h3>\n<ol>\n<li>首先我们去github上clone最新的<a href=\"https://github.com/koajs/koa\">Koa</a>的源代码。然后源码结构如下：</li>\n</ol>\n<p><a target=\"_blank\" rel=\"noopener noreferrer\" href=\"https://camo.githubusercontent.com/321c954731ac3367b9cd4c05c9cd46e066939499/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323031392f706e672f3637363630302f313537373735353633333636372d32626434663631612d643533322d343336302d396164312d3937363262383131396130392e706e6723616c69676e3d6c65667426646973706c61793d696e6c696e65266865696768743d353332266e616d653d696d6167652e706e67266f726967696e4865696768743d353332266f726967696e57696474683d3332362673697a653d3332313338267374617475733d646f6e65267374796c653d6e6f6e652677696474683d333236\"><img src=\"https://camo.githubusercontent.com/321c954731ac3367b9cd4c05c9cd46e066939499/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323031392f706e672f3637363630302f313537373735353633333636372d32626434663631612d643533322d343336302d396164312d3937363262383131396130392e706e6723616c69676e3d6c65667426646973706c61793d696e6c696e65266865696768743d353332266e616d653d696d6167652e706e67266f726967696e4865696768743d353332266f726967696e57696474683d3332362673697a653d3332313338267374617475733d646f6e65267374796c653d6e6f6e652677696474683d333236\" alt=\"image.png\" data-canonical-src=\"https://cdn.nlark.com/yuque/0/2019/png/676600/1577755633667-2bd4f61a-d532-4360-9ad1-9762b8119a09.png#align=left&display=inline&height=532&name=image.png&originHeight=532&originWidth=326&size=32138&status=done&style=none&width=326\" style=\"max-width:100%;\"></a></p>\n<ol start=\"2\">\n<li>可以看得出来整个源码的核心代码皆在<code>lib</code>文件，我们在栗子中<code>require('koa')</code>实际上是引入的<code>lib/application.js</code>里面的<code>Application</code>类。下面我们来分析一下我们的<code>listen</code>方法的实现，首先我们看一下这个<code>Application</code>类里面到底有些什么：</li>\n</ol>\n<p><a target=\"_blank\" rel=\"noopener noreferrer\" href=\"https://camo.githubusercontent.com/50bd64e5511e6fc0c4f776a1c75b91a0bab3e1aa/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323031392f706e672f3637363630302f313537373735363833323633342d33356261393936612d363734322d343433332d616239332d3335373537353038653536382e706e6723616c69676e3d6c65667426646973706c61793d696e6c696e65266865696768743d363136266e616d653d696d6167652e706e67266f726967696e4865696768743d363136266f726967696e57696474683d3632312673697a653d3534303830267374617475733d646f6e65267374796c653d6e6f6e652677696474683d363231\"><img src=\"https://camo.githubusercontent.com/50bd64e5511e6fc0c4f776a1c75b91a0bab3e1aa/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323031392f706e672f3637363630302f313537373735363833323633342d33356261393936612d363734322d343433332d616239332d3335373537353038653536382e706e6723616c69676e3d6c65667426646973706c61793d696e6c696e65266865696768743d363136266e616d653d696d6167652e706e67266f726967696e4865696768743d363136266f726967696e57696474683d3632312673697a653d3534303830267374617475733d646f6e65267374796c653d6e6f6e652677696474683d363231\" alt=\"image.png\" data-canonical-src=\"https://cdn.nlark.com/yuque/0/2019/png/676600/1577756832634-35ba996a-6742-4433-ab93-35757508e568.png#align=left&display=inline&height=616&name=image.png&originHeight=616&originWidth=621&size=54080&status=done&style=none&width=621\" style=\"max-width:100%;\"></a></p>\n<ol start=\"3\">\n<li>我们可以看到<code>Application</code>类下有我们的<code>listen</code>方法，方法如下：</li>\n</ol>\n<p><a target=\"_blank\" rel=\"noopener noreferrer\" href=\"https://camo.githubusercontent.com/cf17936cf0b4683d6c063323fae10876e45eae6e/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323031392f706e672f3637363630302f313537373735363933353037322d64393036383361362d326462352d343061612d386535642d3130316664613532653330612e706e6723616c69676e3d6c65667426646973706c61793d696e6c696e65266865696768743d313231266e616d653d696d6167652e706e67266f726967696e4865696768743d313231266f726967696e57696474683d3439322673697a653d3134343339267374617475733d646f6e65267374796c653d6e6f6e652677696474683d343932\"><img src=\"https://camo.githubusercontent.com/cf17936cf0b4683d6c063323fae10876e45eae6e/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323031392f706e672f3637363630302f313537373735363933353037322d64393036383361362d326462352d343061612d386535642d3130316664613532653330612e706e6723616c69676e3d6c65667426646973706c61793d696e6c696e65266865696768743d313231266e616d653d696d6167652e706e67266f726967696e4865696768743d313231266f726967696e57696474683d3439322673697a653d3134343339267374617475733d646f6e65267374796c653d6e6f6e652677696474683d343932\" alt=\"image.png\" data-canonical-src=\"https://cdn.nlark.com/yuque/0/2019/png/676600/1577756935072-d90683a6-2db5-40aa-8e5d-101fda52e30a.png#align=left&display=inline&height=121&name=image.png&originHeight=121&originWidth=492&size=14439&status=done&style=none&width=492\" style=\"max-width:100%;\"></a><br>\n可以看出这里实际上还是通过我们Node.js的http模块，通过createServer创建一个http服务器, 然后listen方法接收我们的端口，这和我们使用原生Node.js创建一个http服务器是一样的。这个this.callback()也就是我们createServer的入参，这个参数是一个函数，是 作为 request 事件的监听函数，这个函数还接收两个参数req、res，也就是我们的请求对象以及响应对象。那我们可以推断出这个<code>listen</code>方法里面的<code>this.callback()</code>实际上也返回是一个函数，这个函数接收req、res两个入参。</p>\n<ol start=\"4\">\n<li>接下来我们再看一下这个<code>this.callback()</code>里的callback方法是啥样的：</li>\n</ol>\n<p><a target=\"_blank\" rel=\"noopener noreferrer\" href=\"https://camo.githubusercontent.com/176b92d3298a6bacc37390ecf7b6caf9d0b2d2e2/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323031392f706e672f3637363630302f313537373735373730373437342d36643163323563642d356666662d343133342d616138352d6662313365326264626432382e706e6723616c69676e3d6c65667426646973706c61793d696e6c696e65266865696768743d323631266e616d653d696d6167652e706e67266f726967696e4865696768743d323631266f726967696e57696474683d3632362673697a653d3333393435267374617475733d646f6e65267374796c653d6e6f6e652677696474683d363236\"><img src=\"https://camo.githubusercontent.com/176b92d3298a6bacc37390ecf7b6caf9d0b2d2e2/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323031392f706e672f3637363630302f313537373735373730373437342d36643163323563642d356666662d343133342d616138352d6662313365326264626432382e706e6723616c69676e3d6c65667426646973706c61793d696e6c696e65266865696768743d323631266e616d653d696d6167652e706e67266f726967696e4865696768743d323631266f726967696e57696474683d3632362673697a653d3333393435267374617475733d646f6e65267374796c653d6e6f6e652677696474683d363236\" alt=\"image.png\" data-canonical-src=\"https://cdn.nlark.com/yuque/0/2019/png/676600/1577757707474-6d1c25cd-5fff-4134-aa85-fb13e2bdbd28.png#align=left&display=inline&height=261&name=image.png&originHeight=261&originWidth=626&size=33945&status=done&style=none&width=626\" style=\"max-width:100%;\"></a><br>\ncallback方法内的第一句fn = compose(this.middleware)，这个this.middleware是我们在Application类中的constructor就定义了，是一个数组，这里实际上存储的就是我们举的栗子中的app.use（）的入参方法，也就是我们Koa的中间件。这个compose方法很重要，主要是控制我们的中间件的执行，下文讲中间件的执行机制会仔细说说这个compose。然后看这个函数返回，果然和我们推断的一样，这个callback方法最终返回的是一个handleRequest方法，接收req，res两个参数。handleRequest方法中，第一句this.createContext方法实际上就是对我们req、res对象的封装：<br>\n<a target=\"_blank\" rel=\"noopener noreferrer\" href=\"https://camo.githubusercontent.com/37944de2d69671d2a30bd0bc2eb358af36bfc485/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323031392f706e672f3637363630302f313537373737363139313833332d31343139653834642d636633662d346164362d393437652d6661653535333534666636392e706e6723616c69676e3d6c65667426646973706c61793d696e6c696e65266865696768743d333034266e616d653d696d6167652e706e67266f726967696e4865696768743d333034266f726967696e57696474683d3633342673697a653d3535303632267374617475733d646f6e65267374796c653d6e6f6e652677696474683d363334\"><img src=\"https://camo.githubusercontent.com/37944de2d69671d2a30bd0bc2eb358af36bfc485/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323031392f706e672f3637363630302f313537373737363139313833332d31343139653834642d636633662d346164362d393437652d6661653535333534666636392e706e6723616c69676e3d6c65667426646973706c61793d696e6c696e65266865696768743d333034266e616d653d696d6167652e706e67266f726967696e4865696768743d333034266f726967696e57696474683d3633342673697a653d3535303632267374617475733d646f6e65267374796c653d6e6f6e652677696474683d363334\" alt=\"image.png\" data-canonical-src=\"https://cdn.nlark.com/yuque/0/2019/png/676600/1577776191833-1419e84d-cf3f-4ad6-947e-fae55354ff69.png#align=left&display=inline&height=304&name=image.png&originHeight=304&originWidth=634&size=55062&status=done&style=none&width=634\" style=\"max-width:100%;\"></a><br>\n通过createContext 创建了我们ctx对象。这个callback方法返回的handleRequest方法第二句是返回了Application类上的handleRequest方法的执行结果（注意这里有“重名”的方法，注意区分），方法如下：<br>\n<a target=\"_blank\" rel=\"noopener noreferrer\" href=\"https://camo.githubusercontent.com/3aa0e9f882243e7b67072a57fe98a88a7745e983/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323031392f706e672f3637363630302f313537373737373336363239332d66646566653063612d383436362d346565312d393263622d6330343935326263303330612e706e6723616c69676e3d6c65667426646973706c61793d696e6c696e65266865696768743d313935266e616d653d696d6167652e706e67266f726967696e4865696768743d313935266f726967696e57696474683d3634332673697a653d3339363533267374617475733d646f6e65267374796c653d6e6f6e652677696474683d363433\"><img src=\"https://camo.githubusercontent.com/3aa0e9f882243e7b67072a57fe98a88a7745e983/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323031392f706e672f3637363630302f313537373737373336363239332d66646566653063612d383436362d346565312d393263622d6330343935326263303330612e706e6723616c69676e3d6c65667426646973706c61793d696e6c696e65266865696768743d313935266e616d653d696d6167652e706e67266f726967696e4865696768743d313935266f726967696e57696474683d3634332673697a653d3339363533267374617475733d646f6e65267374796c653d6e6f6e652677696474683d363433\" alt=\"image.png\" data-canonical-src=\"https://cdn.nlark.com/yuque/0/2019/png/676600/1577777366293-fdefe0ca-8466-4ee1-92cb-c04952bc030a.png#align=left&display=inline&height=195&name=image.png&originHeight=195&originWidth=643&size=39653&status=done&style=none&width=643\" style=\"max-width:100%;\"></a></p>\n<p>这个方法接收两个参数: 我们的compose的返回结果fn、ctx对象，主要是对我们请求的处理以及错误的统一捕获以及处理。</p>\n<h3>3. 执行一下我们的栗子：扒一扒中间件的执行机制</h3>\n<p>Koa的中间件执行机制有个形象的称呼-洋葱圈模型。我们先执行栗子代码，看看输出的结果到底是什么？<br>\n    <a target=\"_blank\" rel=\"noopener noreferrer\" href=\"https://camo.githubusercontent.com/44ca564a6bfb6b968e69413974297c386450292c/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323031392f706e672f3637363630302f313537373737383235323837332d33306264613436642d616632382d343264612d383137632d6536643532376561346539652e706e6723616c69676e3d6c65667426646973706c61793d696e6c696e65266865696768743d313036266e616d653d696d6167652e706e67266f726967696e4865696768743d313036266f726967696e57696474683d3239392673697a653d34353234267374617475733d646f6e65267374796c653d6e6f6e652677696474683d323939\"><img src=\"https://camo.githubusercontent.com/44ca564a6bfb6b968e69413974297c386450292c/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323031392f706e672f3637363630302f313537373737383235323837332d33306264613436642d616632382d343264612d383137632d6536643532376561346539652e706e6723616c69676e3d6c65667426646973706c61793d696e6c696e65266865696768743d313036266e616d653d696d6167652e706e67266f726967696e4865696768743d313036266f726967696e57696474683d3239392673697a653d34353234267374617475733d646f6e65267374796c653d6e6f6e652677696474683d323939\" alt=\"image.png\" data-canonical-src=\"https://cdn.nlark.com/yuque/0/2019/png/676600/1577778252873-30bda46d-af28-42da-817c-e6d527ea4e9e.png#align=left&display=inline&height=106&name=image.png&originHeight=106&originWidth=299&size=4524&status=done&style=none&width=299\" style=\"max-width:100%;\"></a></p>\n<h5>从use方法说起</h5>\n<p><a target=\"_blank\" rel=\"noopener noreferrer\" href=\"https://camo.githubusercontent.com/5e2a08feb193b97fa1f13ee462777b9dc97649b8/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323031392f706e672f3637363630302f313537373737383335363433392d36383932616234662d346566382d346239632d623762652d6232653436316262383333372e706e6723616c69676e3d6c65667426646973706c61793d696e6c696e65266865696768743d323639266e616d653d696d6167652e706e67266f726967696e4865696768743d323639266f726967696e57696474683d3738372673697a653d3433393536267374617475733d646f6e65267374796c653d6e6f6e652677696474683d373837\"><img src=\"https://camo.githubusercontent.com/5e2a08feb193b97fa1f13ee462777b9dc97649b8/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323031392f706e672f3637363630302f313537373737383335363433392d36383932616234662d346566382d346239632d623762652d6232653436316262383333372e706e6723616c69676e3d6c65667426646973706c61793d696e6c696e65266865696768743d323639266e616d653d696d6167652e706e67266f726967696e4865696768743d323639266f726967696e57696474683d3738372673697a653d3433393536267374617475733d646f6e65267374796c653d6e6f6e652677696474683d373837\" alt=\"image.png\" data-canonical-src=\"https://cdn.nlark.com/yuque/0/2019/png/676600/1577778356439-6892ab4f-4ef8-4b9c-b7be-b2e461bb8337.png#align=left&display=inline&height=269&name=image.png&originHeight=269&originWidth=787&size=43956&status=done&style=none&width=787\" style=\"max-width:100%;\"></a><br>\napp.use实际上就是调用了Applcation类下面的use方法，这个方法主要是先判断入参形式是否是一个函数等（参数校验），如果入参是一个generator函数，这也就是koa1中的写法，在koa2中需要koa-convert去转换一下。然后将我们入参传入的中间件函数push到this.middleware数组中。<br>\n再回到上文提到的callback函数，我们的中间件执行机制的核心就是compose(this.middleware),下面我们来分析一下compose函数的源码：<br>\n<a target=\"_blank\" rel=\"noopener noreferrer\" href=\"https://camo.githubusercontent.com/8f9c713e436d0a88c29b050490e83b5787fe80a3/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323031392f706e672f3637363630302f313537373738333238303038352d37373063393937642d623361312d346139332d613238612d3131343036303234376561662e706e6723616c69676e3d6c65667426646973706c61793d696e6c696e65266865696768743d363432266e616d653d696d6167652e706e67266f726967696e4865696768743d363432266f726967696e57696474683d3839322673697a653d3931323330267374617475733d646f6e65267374796c653d6e6f6e652677696474683d383932\"><img src=\"https://camo.githubusercontent.com/8f9c713e436d0a88c29b050490e83b5787fe80a3/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323031392f706e672f3637363630302f313537373738333238303038352d37373063393937642d623361312d346139332d613238612d3131343036303234376561662e706e6723616c69676e3d6c65667426646973706c61793d696e6c696e65266865696768743d363432266e616d653d696d6167652e706e67266f726967696e4865696768743d363432266f726967696e57696474683d3839322673697a653d3931323330267374617475733d646f6e65267374796c653d6e6f6e652677696474683d383932\" alt=\"image.png\" data-canonical-src=\"https://cdn.nlark.com/yuque/0/2019/png/676600/1577783280085-770c997d-b3a1-4a93-a28a-114060247eaf.png#align=left&display=inline&height=642&name=image.png&originHeight=642&originWidth=892&size=91230&status=done&style=none&width=892\" style=\"max-width:100%;\"></a></p>\n<ol>\n<li>先校验我们middleware的参数正确性，是否是数组，数组项是否为函数；</li>\n<li>compose函数实际上是返回一个function，这个返回的function，在上面也提及，最终是传入到handleRequest方法中然后传入ctx参数：fnMiddleware(context)。</li>\n<li>再回到我们的compose中return的这个function，接收两个参数：第一个就是我们handleRequest方法传入的ctx对象，第二个next呢，实际上是传入的一个方法，这个方法是在所有middleware执行完毕后，最后执行处理的函数。这个function核心就是递归执行我们的middleware。要理解这段代码，先要理解<code>Promise.reslove()</code>。</li>\n</ol>\n<div class=\"highlight highlight-source-js\"><pre><span class=\"pl-c\"><span class=\"pl-c\">//</span> Promise.reslove返回一个fulfillled状态的promise对象</span>\n<span class=\"pl-c\"><span class=\"pl-c\">//</span> 可以看成new Promise()的快捷方式</span>\n\n<span class=\"pl-c1\">Promise</span>.<span class=\"pl-en\">reslove</span>(<span class=\"pl-en\">fn</span>(context, <span class=\"pl-smi\">dispatch</span>.<span class=\"pl-en\">bind</span>(<span class=\"pl-c1\">null</span>, i<span class=\"pl-k\">+</span><span class=\"pl-c1\">1</span>)))；\n<span class=\"pl-c\"><span class=\"pl-c\">//</span> 实际上是等于</span>\n<span class=\"pl-k\">new</span> <span class=\"pl-en\">Promise</span>((<span class=\"pl-smi\">relove</span>, <span class=\"pl-smi\">reject</span>) <span class=\"pl-k\">=></span> {\n  <span class=\"pl-en\">reslove</span>(<span class=\"pl-en\">fn</span>(context, <span class=\"pl-smi\">dispatch</span>.<span class=\"pl-en\">bind</span>(<span class=\"pl-c1\">null</span>, i<span class=\"pl-k\">+</span><span class=\"pl-c1\">1</span>)));\n})</pre></div>\n<ol start=\"4\">\n<li>仔细阅读这个function, 它是先定义了一个index（利用我们的闭包每次执行一次dispatch方法去改变index），执行了dispatch(0),这个dispatch方法就是我们执行机制的实现，dispatch函数里面如果没有执行到最后一个middleware，就返回了<code>Promise.reslove(fn(context, dispatch.bind(null, i + 1)))</code>, 这个<code>fn(context, dispatch.bind(null, i + 1))</code>也就是执行我们通过<code>app.use</code>加入的middleware函数，middleware函数统一接收两个参数一个是context，一个是next：下一个middleware函数，这样可以看出来如果我们koa中某个中间件没有执行next方法，那么之后加入的中间件是不会执行的。这也就形成了我们的<code>洋葱圈模型</code>。</li>\n</ol>\n<div class=\"highlight highlight-source-js\"><pre><span class=\"pl-c\"><span class=\"pl-c\">//</span> 核心方法：递归调用我们middlewares, 基于Promise进行异步流程控制；</span>\n<span class=\"pl-c\"><span class=\"pl-c\">//</span> Promise.resolve()返回的是一个thenable对象；</span>\n<span class=\"pl-c\"><span class=\"pl-c\">//</span> 所以我们koa2中中间件都基于async函数，await等待下个中间件方法的执行；</span>\n<span class=\"pl-k\">return</span> <span class=\"pl-k\">function</span> (<span class=\"pl-smi\">context</span>, <span class=\"pl-smi\">next</span>) {\n    <span class=\"pl-c\"><span class=\"pl-c\">//</span> last called middleware #</span>\n    <span class=\"pl-k\">let</span> index <span class=\"pl-k\">=</span> <span class=\"pl-k\">-</span><span class=\"pl-c1\">1</span>\n    <span class=\"pl-k\">return</span> <span class=\"pl-en\">dispatch</span>(<span class=\"pl-c1\">0</span>)\n    <span class=\"pl-k\">function</span> <span class=\"pl-en\">dispatch</span> (<span class=\"pl-smi\">i</span>) {\n      <span class=\"pl-k\">if</span> (i <span class=\"pl-k\"><=</span> index) <span class=\"pl-k\">return</span> <span class=\"pl-c1\">Promise</span>.<span class=\"pl-c1\">reject</span>(<span class=\"pl-k\">new</span> <span class=\"pl-en\">Error</span>(<span class=\"pl-s\"><span class=\"pl-pds\">'</span>next() called multiple times<span class=\"pl-pds\">'</span></span>))\n      index <span class=\"pl-k\">=</span> i\n      <span class=\"pl-k\">let</span> fn <span class=\"pl-k\">=</span> middleware[i]\n      <span class=\"pl-k\">if</span> (i <span class=\"pl-k\">===</span> <span class=\"pl-smi\">middleware</span>.<span class=\"pl-c1\">length</span>) fn <span class=\"pl-k\">=</span> next\n      <span class=\"pl-k\">if</span> (<span class=\"pl-k\">!</span>fn) <span class=\"pl-k\">return</span> <span class=\"pl-c1\">Promise</span>.<span class=\"pl-c1\">resolve</span>()\n      <span class=\"pl-k\">try</span> {\n        <span class=\"pl-k\">return</span> <span class=\"pl-c1\">Promise</span>.<span class=\"pl-c1\">resolve</span>(<span class=\"pl-en\">fn</span>(context, <span class=\"pl-smi\">dispatch</span>.<span class=\"pl-en\">bind</span>(<span class=\"pl-c1\">null</span>, i <span class=\"pl-k\">+</span> <span class=\"pl-c1\">1</span>)));\n      } <span class=\"pl-k\">catch</span> (err) {\n        <span class=\"pl-k\">return</span> <span class=\"pl-c1\">Promise</span>.<span class=\"pl-c1\">reject</span>(err)\n      }\n    }\n  }</pre></div>\n<h2>四、总结</h2>\n<ol>\n<li>Koa这个框架是小而精美的，它的源码是也非常少，只有一千多行。中间件的执行机制主要是读懂这个koa-compose的代码，多个中间件会形成一个<code>先进后出</code>的栈结构，当前中间件掌握下一个中间件的执行权。</li>\n<li>Koa本身的功能可能是满足不了我们日常开发的需求的，我们可以通过许多的第三方的包，也可以自定义中间件来辅助我们的开发。（了解了中间件机制，自定义一个中间件就非常容易了）</li>\n<li><code>Koa1</code>借助<code>co</code> and <code>generator</code>管理我们的中间件，<code>Koa2</code>借助<code>async await</code>（async函数返回的是<code>Promise</code>对象）管理我们的中间件。</li>\n</ol>\n<h3>五、参考文档</h3>\n<ol>\n<li><a href=\"https://zhuanlan.zhihu.com/p/33316664\" rel=\"nofollow\">Koa2 还有多久取代 Express</a></li>\n<li><a href=\"https://blog.csdn.net/zramals/article/details/80653715\" rel=\"nofollow\">Koa vs Express && Koa1 vs Koa2</a></li>\n</ol>\n      </td>\n    </tr>\n  </tbody>\n</table>",
      "title": "Koa源码分析（中间件执行机制、Koa2与Koa1比较)",
      "time": "2020-01-01"
    },
    {
      "html": "<table class=\"d-block\" data-paste-markdown-skip>\n  <tbody class=\"d-block\">\n    <tr class=\"d-block\">\n      <td class=\"d-block comment-body markdown-body  js-comment-body\">\n          <h2>一、why Koa</h2>\n<ol>\n<li><code>Koa</code>是由<code>Express</code>原班人马打造，但是相较于<code>Express</code>的大而全，<code>Koa</code>是小而精的。<code>Koa</code>没有绑定很多的框架以及插件，更容易让我们进行扩展，包括现在较为流行的<code>EggJS</code> and <code>ThinkJS</code>都是基于<code>Koa</code>开发的。</li>\n<li><code>Koa</code>避免了Express中间件基于callback形式的调用，它使用了我们JS新版本特性，<code>Koa1</code>中间件借助于我们的<code>co</code> and <code>generator</code>特性，<code>Koa2</code>借助了<code>Promise</code> and <code>async await</code>特性，更好的进行流程控制以及catch我们的错误。</li>\n<li><code>Koa</code>提供了<code>Context</code>对象，实际上是对我们node中<code>request</code> and <code>response</code>对象的封装，我们不需要很多的手动处理我们的<code>request</code> and <code>response</code>对象。<code>Context</code>是贯穿我们整个请求的过程，我们可以中间件需要传递参数挂在到<code>Context</code>对象上。（栗子：我们可以将用户信息挂在它上面，通过<code>ctx.state.user</code>进行操作。）</li>\n<li><code>Koa</code>的中间件执行机制：<code>洋葱圈模型</code>。它不是按顺序执行的，多个中间件会形成一个<code>先进后出</code>的栈结构，当前中间件掌握下一个中间件的执行权，对于流程控制以及后置处理逻辑的实现非常有效。</li>\n</ol>\n<h2>二、Koa2与Koa1的比较</h2>\n<ol>\n<li>中间件的管理方式：<code>Koa1</code>借助<code>co</code> and <code>generator</code>管理我们的中间件，<code>Koa2</code>借助<code>async await</code>（async函数返回的是<code>Promise</code>对象）管理我们的中间件。</li>\n<li><code>context</code>对象获取：<code>Koa1</code>通过<code>this</code>对象（<code>this.req</code>,<code>this.res</code>）获取，<code>Koa2</code>通过<code>ctx</code>参数（<code>ctx.req</code>, <code>ctx.res</code>）获取。</li>\n<li><code>Koa2</code>的轮子多且成熟，生态比<code>Koa1</code>丰富。</li>\n</ol>\n<h2>三、举个栗子，剖析源码</h2>\n<h3>1. 栗子</h3>\n<p><a target=\"_blank\" rel=\"noopener noreferrer\" href=\"https://camo.githubusercontent.com/b4390ee94df94f96610941a183d70ea13aaba2ae/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323031392f706e672f3637363630302f313537373735353539393033312d61303663626330622d386333612d343166622d623939662d3962666266643964333561312e706e6723616c69676e3d6c65667426646973706c61793d696e6c696e65266865696768743d353133266e616d653d696d6167652e706e67266f726967696e4865696768743d353133266f726967696e57696474683d3438332673697a653d3533373736267374617475733d646f6e65267374796c653d6e6f6e652677696474683d343833\"><img src=\"https://camo.githubusercontent.com/b4390ee94df94f96610941a183d70ea13aaba2ae/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323031392f706e672f3637363630302f313537373735353539393033312d61303663626330622d386333612d343166622d623939662d3962666266643964333561312e706e6723616c69676e3d6c65667426646973706c61793d696e6c696e65266865696768743d353133266e616d653d696d6167652e706e67266f726967696e4865696768743d353133266f726967696e57696474683d3438332673697a653d3533373736267374617475733d646f6e65267374796c653d6e6f6e652677696474683d343833\" alt=\"image.png\" data-canonical-src=\"https://cdn.nlark.com/yuque/0/2019/png/676600/1577755599031-a06cbc0b-8c3a-41fb-b99f-9bfbfd9d35a1.png#align=left&display=inline&height=513&name=image.png&originHeight=513&originWidth=483&size=53776&status=done&style=none&width=483\" style=\"max-width:100%;\"></a><br>\n这段代码呢，通过<code>listen</code>方法创建了我们的http服务器，端口是<code>3000</code>。并且通过<code>use</code>方法传入了三个<code>koa</code>中间件, 并且<code>console</code>出我们的执行结果。</p>\n<h3>2. 从<code>listen</code>方法说起</h3>\n<ol>\n<li>首先我们去github上clone最新的<a href=\"https://github.com/koajs/koa\">Koa</a>的源代码。然后源码结构如下：</li>\n</ol>\n<p><a target=\"_blank\" rel=\"noopener noreferrer\" href=\"https://camo.githubusercontent.com/321c954731ac3367b9cd4c05c9cd46e066939499/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323031392f706e672f3637363630302f313537373735353633333636372d32626434663631612d643533322d343336302d396164312d3937363262383131396130392e706e6723616c69676e3d6c65667426646973706c61793d696e6c696e65266865696768743d353332266e616d653d696d6167652e706e67266f726967696e4865696768743d353332266f726967696e57696474683d3332362673697a653d3332313338267374617475733d646f6e65267374796c653d6e6f6e652677696474683d333236\"><img src=\"https://camo.githubusercontent.com/321c954731ac3367b9cd4c05c9cd46e066939499/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323031392f706e672f3637363630302f313537373735353633333636372d32626434663631612d643533322d343336302d396164312d3937363262383131396130392e706e6723616c69676e3d6c65667426646973706c61793d696e6c696e65266865696768743d353332266e616d653d696d6167652e706e67266f726967696e4865696768743d353332266f726967696e57696474683d3332362673697a653d3332313338267374617475733d646f6e65267374796c653d6e6f6e652677696474683d333236\" alt=\"image.png\" data-canonical-src=\"https://cdn.nlark.com/yuque/0/2019/png/676600/1577755633667-2bd4f61a-d532-4360-9ad1-9762b8119a09.png#align=left&display=inline&height=532&name=image.png&originHeight=532&originWidth=326&size=32138&status=done&style=none&width=326\" style=\"max-width:100%;\"></a></p>\n<ol start=\"2\">\n<li>可以看得出来整个源码的核心代码皆在<code>lib</code>文件，我们在栗子中<code>require('koa')</code>实际上是引入的<code>lib/application.js</code>里面的<code>Application</code>类。下面我们来分析一下我们的<code>listen</code>方法的实现，首先我们看一下这个<code>Application</code>类里面到底有些什么：</li>\n</ol>\n<p><a target=\"_blank\" rel=\"noopener noreferrer\" href=\"https://camo.githubusercontent.com/50bd64e5511e6fc0c4f776a1c75b91a0bab3e1aa/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323031392f706e672f3637363630302f313537373735363833323633342d33356261393936612d363734322d343433332d616239332d3335373537353038653536382e706e6723616c69676e3d6c65667426646973706c61793d696e6c696e65266865696768743d363136266e616d653d696d6167652e706e67266f726967696e4865696768743d363136266f726967696e57696474683d3632312673697a653d3534303830267374617475733d646f6e65267374796c653d6e6f6e652677696474683d363231\"><img src=\"https://camo.githubusercontent.com/50bd64e5511e6fc0c4f776a1c75b91a0bab3e1aa/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323031392f706e672f3637363630302f313537373735363833323633342d33356261393936612d363734322d343433332d616239332d3335373537353038653536382e706e6723616c69676e3d6c65667426646973706c61793d696e6c696e65266865696768743d363136266e616d653d696d6167652e706e67266f726967696e4865696768743d363136266f726967696e57696474683d3632312673697a653d3534303830267374617475733d646f6e65267374796c653d6e6f6e652677696474683d363231\" alt=\"image.png\" data-canonical-src=\"https://cdn.nlark.com/yuque/0/2019/png/676600/1577756832634-35ba996a-6742-4433-ab93-35757508e568.png#align=left&display=inline&height=616&name=image.png&originHeight=616&originWidth=621&size=54080&status=done&style=none&width=621\" style=\"max-width:100%;\"></a></p>\n<ol start=\"3\">\n<li>我们可以看到<code>Application</code>类下有我们的<code>listen</code>方法，方法如下：</li>\n</ol>\n<p><a target=\"_blank\" rel=\"noopener noreferrer\" href=\"https://camo.githubusercontent.com/cf17936cf0b4683d6c063323fae10876e45eae6e/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323031392f706e672f3637363630302f313537373735363933353037322d64393036383361362d326462352d343061612d386535642d3130316664613532653330612e706e6723616c69676e3d6c65667426646973706c61793d696e6c696e65266865696768743d313231266e616d653d696d6167652e706e67266f726967696e4865696768743d313231266f726967696e57696474683d3439322673697a653d3134343339267374617475733d646f6e65267374796c653d6e6f6e652677696474683d343932\"><img src=\"https://camo.githubusercontent.com/cf17936cf0b4683d6c063323fae10876e45eae6e/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323031392f706e672f3637363630302f313537373735363933353037322d64393036383361362d326462352d343061612d386535642d3130316664613532653330612e706e6723616c69676e3d6c65667426646973706c61793d696e6c696e65266865696768743d313231266e616d653d696d6167652e706e67266f726967696e4865696768743d313231266f726967696e57696474683d3439322673697a653d3134343339267374617475733d646f6e65267374796c653d6e6f6e652677696474683d343932\" alt=\"image.png\" data-canonical-src=\"https://cdn.nlark.com/yuque/0/2019/png/676600/1577756935072-d90683a6-2db5-40aa-8e5d-101fda52e30a.png#align=left&display=inline&height=121&name=image.png&originHeight=121&originWidth=492&size=14439&status=done&style=none&width=492\" style=\"max-width:100%;\"></a><br>\n可以看出这里实际上还是通过我们Node.js的http模块，通过createServer创建一个http服务器, 然后listen方法接收我们的端口，这和我们使用原生Node.js创建一个http服务器是一样的。这个this.callback()也就是我们createServer的入参，这个参数是一个函数，是 作为 request 事件的监听函数，这个函数还接收两个参数req、res，也就是我们的请求对象以及响应对象。那我们可以推断出这个<code>listen</code>方法里面的<code>this.callback()</code>实际上也返回是一个函数，这个函数接收req、res两个入参。</p>\n<ol start=\"4\">\n<li>接下来我们再看一下这个<code>this.callback()</code>里的callback方法是啥样的：</li>\n</ol>\n<p><a target=\"_blank\" rel=\"noopener noreferrer\" href=\"https://camo.githubusercontent.com/176b92d3298a6bacc37390ecf7b6caf9d0b2d2e2/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323031392f706e672f3637363630302f313537373735373730373437342d36643163323563642d356666662d343133342d616138352d6662313365326264626432382e706e6723616c69676e3d6c65667426646973706c61793d696e6c696e65266865696768743d323631266e616d653d696d6167652e706e67266f726967696e4865696768743d323631266f726967696e57696474683d3632362673697a653d3333393435267374617475733d646f6e65267374796c653d6e6f6e652677696474683d363236\"><img src=\"https://camo.githubusercontent.com/176b92d3298a6bacc37390ecf7b6caf9d0b2d2e2/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323031392f706e672f3637363630302f313537373735373730373437342d36643163323563642d356666662d343133342d616138352d6662313365326264626432382e706e6723616c69676e3d6c65667426646973706c61793d696e6c696e65266865696768743d323631266e616d653d696d6167652e706e67266f726967696e4865696768743d323631266f726967696e57696474683d3632362673697a653d3333393435267374617475733d646f6e65267374796c653d6e6f6e652677696474683d363236\" alt=\"image.png\" data-canonical-src=\"https://cdn.nlark.com/yuque/0/2019/png/676600/1577757707474-6d1c25cd-5fff-4134-aa85-fb13e2bdbd28.png#align=left&display=inline&height=261&name=image.png&originHeight=261&originWidth=626&size=33945&status=done&style=none&width=626\" style=\"max-width:100%;\"></a><br>\ncallback方法内的第一句fn = compose(this.middleware)，这个this.middleware是我们在Application类中的constructor就定义了，是一个数组，这里实际上存储的就是我们举的栗子中的app.use（）的入参方法，也就是我们Koa的中间件。这个compose方法很重要，主要是控制我们的中间件的执行，下文讲中间件的执行机制会仔细说说这个compose。然后看这个函数返回，果然和我们推断的一样，这个callback方法最终返回的是一个handleRequest方法，接收req，res两个参数。handleRequest方法中，第一句this.createContext方法实际上就是对我们req、res对象的封装：<br>\n<a target=\"_blank\" rel=\"noopener noreferrer\" href=\"https://camo.githubusercontent.com/37944de2d69671d2a30bd0bc2eb358af36bfc485/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323031392f706e672f3637363630302f313537373737363139313833332d31343139653834642d636633662d346164362d393437652d6661653535333534666636392e706e6723616c69676e3d6c65667426646973706c61793d696e6c696e65266865696768743d333034266e616d653d696d6167652e706e67266f726967696e4865696768743d333034266f726967696e57696474683d3633342673697a653d3535303632267374617475733d646f6e65267374796c653d6e6f6e652677696474683d363334\"><img src=\"https://camo.githubusercontent.com/37944de2d69671d2a30bd0bc2eb358af36bfc485/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323031392f706e672f3637363630302f313537373737363139313833332d31343139653834642d636633662d346164362d393437652d6661653535333534666636392e706e6723616c69676e3d6c65667426646973706c61793d696e6c696e65266865696768743d333034266e616d653d696d6167652e706e67266f726967696e4865696768743d333034266f726967696e57696474683d3633342673697a653d3535303632267374617475733d646f6e65267374796c653d6e6f6e652677696474683d363334\" alt=\"image.png\" data-canonical-src=\"https://cdn.nlark.com/yuque/0/2019/png/676600/1577776191833-1419e84d-cf3f-4ad6-947e-fae55354ff69.png#align=left&display=inline&height=304&name=image.png&originHeight=304&originWidth=634&size=55062&status=done&style=none&width=634\" style=\"max-width:100%;\"></a><br>\n通过createContext 创建了我们ctx对象。这个callback方法返回的handleRequest方法第二句是返回了Application类上的handleRequest方法的执行结果（注意这里有“重名”的方法，注意区分），方法如下：<br>\n<a target=\"_blank\" rel=\"noopener noreferrer\" href=\"https://camo.githubusercontent.com/3aa0e9f882243e7b67072a57fe98a88a7745e983/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323031392f706e672f3637363630302f313537373737373336363239332d66646566653063612d383436362d346565312d393263622d6330343935326263303330612e706e6723616c69676e3d6c65667426646973706c61793d696e6c696e65266865696768743d313935266e616d653d696d6167652e706e67266f726967696e4865696768743d313935266f726967696e57696474683d3634332673697a653d3339363533267374617475733d646f6e65267374796c653d6e6f6e652677696474683d363433\"><img src=\"https://camo.githubusercontent.com/3aa0e9f882243e7b67072a57fe98a88a7745e983/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323031392f706e672f3637363630302f313537373737373336363239332d66646566653063612d383436362d346565312d393263622d6330343935326263303330612e706e6723616c69676e3d6c65667426646973706c61793d696e6c696e65266865696768743d313935266e616d653d696d6167652e706e67266f726967696e4865696768743d313935266f726967696e57696474683d3634332673697a653d3339363533267374617475733d646f6e65267374796c653d6e6f6e652677696474683d363433\" alt=\"image.png\" data-canonical-src=\"https://cdn.nlark.com/yuque/0/2019/png/676600/1577777366293-fdefe0ca-8466-4ee1-92cb-c04952bc030a.png#align=left&display=inline&height=195&name=image.png&originHeight=195&originWidth=643&size=39653&status=done&style=none&width=643\" style=\"max-width:100%;\"></a></p>\n<p>这个方法接收两个参数: 我们的compose的返回结果fn、ctx对象，主要是对我们请求的处理以及错误的统一捕获以及处理。</p>\n<h3>3. 执行一下我们的栗子：扒一扒中间件的执行机制</h3>\n<p>Koa的中间件执行机制有个形象的称呼-洋葱圈模型。我们先执行栗子代码，看看输出的结果到底是什么？<br>\n    <a target=\"_blank\" rel=\"noopener noreferrer\" href=\"https://camo.githubusercontent.com/44ca564a6bfb6b968e69413974297c386450292c/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323031392f706e672f3637363630302f313537373737383235323837332d33306264613436642d616632382d343264612d383137632d6536643532376561346539652e706e6723616c69676e3d6c65667426646973706c61793d696e6c696e65266865696768743d313036266e616d653d696d6167652e706e67266f726967696e4865696768743d313036266f726967696e57696474683d3239392673697a653d34353234267374617475733d646f6e65267374796c653d6e6f6e652677696474683d323939\"><img src=\"https://camo.githubusercontent.com/44ca564a6bfb6b968e69413974297c386450292c/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323031392f706e672f3637363630302f313537373737383235323837332d33306264613436642d616632382d343264612d383137632d6536643532376561346539652e706e6723616c69676e3d6c65667426646973706c61793d696e6c696e65266865696768743d313036266e616d653d696d6167652e706e67266f726967696e4865696768743d313036266f726967696e57696474683d3239392673697a653d34353234267374617475733d646f6e65267374796c653d6e6f6e652677696474683d323939\" alt=\"image.png\" data-canonical-src=\"https://cdn.nlark.com/yuque/0/2019/png/676600/1577778252873-30bda46d-af28-42da-817c-e6d527ea4e9e.png#align=left&display=inline&height=106&name=image.png&originHeight=106&originWidth=299&size=4524&status=done&style=none&width=299\" style=\"max-width:100%;\"></a></p>\n<h5>从use方法说起</h5>\n<p><a target=\"_blank\" rel=\"noopener noreferrer\" href=\"https://camo.githubusercontent.com/5e2a08feb193b97fa1f13ee462777b9dc97649b8/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323031392f706e672f3637363630302f313537373737383335363433392d36383932616234662d346566382d346239632d623762652d6232653436316262383333372e706e6723616c69676e3d6c65667426646973706c61793d696e6c696e65266865696768743d323639266e616d653d696d6167652e706e67266f726967696e4865696768743d323639266f726967696e57696474683d3738372673697a653d3433393536267374617475733d646f6e65267374796c653d6e6f6e652677696474683d373837\"><img src=\"https://camo.githubusercontent.com/5e2a08feb193b97fa1f13ee462777b9dc97649b8/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323031392f706e672f3637363630302f313537373737383335363433392d36383932616234662d346566382d346239632d623762652d6232653436316262383333372e706e6723616c69676e3d6c65667426646973706c61793d696e6c696e65266865696768743d323639266e616d653d696d6167652e706e67266f726967696e4865696768743d323639266f726967696e57696474683d3738372673697a653d3433393536267374617475733d646f6e65267374796c653d6e6f6e652677696474683d373837\" alt=\"image.png\" data-canonical-src=\"https://cdn.nlark.com/yuque/0/2019/png/676600/1577778356439-6892ab4f-4ef8-4b9c-b7be-b2e461bb8337.png#align=left&display=inline&height=269&name=image.png&originHeight=269&originWidth=787&size=43956&status=done&style=none&width=787\" style=\"max-width:100%;\"></a><br>\napp.use实际上就是调用了Applcation类下面的use方法，这个方法主要是先判断入参形式是否是一个函数等（参数校验），如果入参是一个generator函数，这也就是koa1中的写法，在koa2中需要koa-convert去转换一下。然后将我们入参传入的中间件函数push到this.middleware数组中。<br>\n再回到上文提到的callback函数，我们的中间件执行机制的核心就是compose(this.middleware),下面我们来分析一下compose函数的源码：<br>\n<a target=\"_blank\" rel=\"noopener noreferrer\" href=\"https://camo.githubusercontent.com/8f9c713e436d0a88c29b050490e83b5787fe80a3/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323031392f706e672f3637363630302f313537373738333238303038352d37373063393937642d623361312d346139332d613238612d3131343036303234376561662e706e6723616c69676e3d6c65667426646973706c61793d696e6c696e65266865696768743d363432266e616d653d696d6167652e706e67266f726967696e4865696768743d363432266f726967696e57696474683d3839322673697a653d3931323330267374617475733d646f6e65267374796c653d6e6f6e652677696474683d383932\"><img src=\"https://camo.githubusercontent.com/8f9c713e436d0a88c29b050490e83b5787fe80a3/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323031392f706e672f3637363630302f313537373738333238303038352d37373063393937642d623361312d346139332d613238612d3131343036303234376561662e706e6723616c69676e3d6c65667426646973706c61793d696e6c696e65266865696768743d363432266e616d653d696d6167652e706e67266f726967696e4865696768743d363432266f726967696e57696474683d3839322673697a653d3931323330267374617475733d646f6e65267374796c653d6e6f6e652677696474683d383932\" alt=\"image.png\" data-canonical-src=\"https://cdn.nlark.com/yuque/0/2019/png/676600/1577783280085-770c997d-b3a1-4a93-a28a-114060247eaf.png#align=left&display=inline&height=642&name=image.png&originHeight=642&originWidth=892&size=91230&status=done&style=none&width=892\" style=\"max-width:100%;\"></a></p>\n<ol>\n<li>先校验我们middleware的参数正确性，是否是数组，数组项是否为函数；</li>\n<li>compose函数实际上是返回一个function，这个返回的function，在上面也提及，最终是传入到handleRequest方法中然后传入ctx参数：fnMiddleware(context)。</li>\n<li>再回到我们的compose中return的这个function，接收两个参数：第一个就是我们handleRequest方法传入的ctx对象，第二个next呢，实际上是传入的一个方法，这个方法是在所有middleware执行完毕后，最后执行处理的函数。这个function核心就是递归执行我们的middleware。要理解这段代码，先要理解<code>Promise.reslove()</code>。</li>\n</ol>\n<div class=\"highlight highlight-source-js\"><pre><span class=\"pl-c\"><span class=\"pl-c\">//</span> Promise.reslove返回一个fulfillled状态的promise对象</span>\n<span class=\"pl-c\"><span class=\"pl-c\">//</span> 可以看成new Promise()的快捷方式</span>\n\n<span class=\"pl-c1\">Promise</span>.<span class=\"pl-en\">reslove</span>(<span class=\"pl-en\">fn</span>(context, <span class=\"pl-smi\">dispatch</span>.<span class=\"pl-en\">bind</span>(<span class=\"pl-c1\">null</span>, i<span class=\"pl-k\">+</span><span class=\"pl-c1\">1</span>)))；\n<span class=\"pl-c\"><span class=\"pl-c\">//</span> 实际上是等于</span>\n<span class=\"pl-k\">new</span> <span class=\"pl-en\">Promise</span>((<span class=\"pl-smi\">relove</span>, <span class=\"pl-smi\">reject</span>) <span class=\"pl-k\">=></span> {\n  <span class=\"pl-en\">reslove</span>(<span class=\"pl-en\">fn</span>(context, <span class=\"pl-smi\">dispatch</span>.<span class=\"pl-en\">bind</span>(<span class=\"pl-c1\">null</span>, i<span class=\"pl-k\">+</span><span class=\"pl-c1\">1</span>)));\n})</pre></div>\n<ol start=\"4\">\n<li>仔细阅读这个function, 它是先定义了一个index（利用我们的闭包每次执行一次dispatch方法去改变index），执行了dispatch(0),这个dispatch方法就是我们执行机制的实现，dispatch函数里面如果没有执行到最后一个middleware，就返回了<code>Promise.reslove(fn(context, dispatch.bind(null, i + 1)))</code>, 这个<code>fn(context, dispatch.bind(null, i + 1))</code>也就是执行我们通过<code>app.use</code>加入的middleware函数，middleware函数统一接收两个参数一个是context，一个是next：下一个middleware函数，这样可以看出来如果我们koa中某个中间件没有执行next方法，那么之后加入的中间件是不会执行的。这也就形成了我们的<code>洋葱圈模型</code>。</li>\n</ol>\n<div class=\"highlight highlight-source-js\"><pre><span class=\"pl-c\"><span class=\"pl-c\">//</span> 核心方法：递归调用我们middlewares, 基于Promise进行异步流程控制；</span>\n<span class=\"pl-c\"><span class=\"pl-c\">//</span> Promise.resolve()返回的是一个thenable对象；</span>\n<span class=\"pl-c\"><span class=\"pl-c\">//</span> 所以我们koa2中中间件都基于async函数，await等待下个中间件方法的执行；</span>\n<span class=\"pl-k\">return</span> <span class=\"pl-k\">function</span> (<span class=\"pl-smi\">context</span>, <span class=\"pl-smi\">next</span>) {\n    <span class=\"pl-c\"><span class=\"pl-c\">//</span> last called middleware #</span>\n    <span class=\"pl-k\">let</span> index <span class=\"pl-k\">=</span> <span class=\"pl-k\">-</span><span class=\"pl-c1\">1</span>\n    <span class=\"pl-k\">return</span> <span class=\"pl-en\">dispatch</span>(<span class=\"pl-c1\">0</span>)\n    <span class=\"pl-k\">function</span> <span class=\"pl-en\">dispatch</span> (<span class=\"pl-smi\">i</span>) {\n      <span class=\"pl-k\">if</span> (i <span class=\"pl-k\"><=</span> index) <span class=\"pl-k\">return</span> <span class=\"pl-c1\">Promise</span>.<span class=\"pl-c1\">reject</span>(<span class=\"pl-k\">new</span> <span class=\"pl-en\">Error</span>(<span class=\"pl-s\"><span class=\"pl-pds\">'</span>next() called multiple times<span class=\"pl-pds\">'</span></span>))\n      index <span class=\"pl-k\">=</span> i\n      <span class=\"pl-k\">let</span> fn <span class=\"pl-k\">=</span> middleware[i]\n      <span class=\"pl-k\">if</span> (i <span class=\"pl-k\">===</span> <span class=\"pl-smi\">middleware</span>.<span class=\"pl-c1\">length</span>) fn <span class=\"pl-k\">=</span> next\n      <span class=\"pl-k\">if</span> (<span class=\"pl-k\">!</span>fn) <span class=\"pl-k\">return</span> <span class=\"pl-c1\">Promise</span>.<span class=\"pl-c1\">resolve</span>()\n      <span class=\"pl-k\">try</span> {\n        <span class=\"pl-k\">return</span> <span class=\"pl-c1\">Promise</span>.<span class=\"pl-c1\">resolve</span>(<span class=\"pl-en\">fn</span>(context, <span class=\"pl-smi\">dispatch</span>.<span class=\"pl-en\">bind</span>(<span class=\"pl-c1\">null</span>, i <span class=\"pl-k\">+</span> <span class=\"pl-c1\">1</span>)));\n      } <span class=\"pl-k\">catch</span> (err) {\n        <span class=\"pl-k\">return</span> <span class=\"pl-c1\">Promise</span>.<span class=\"pl-c1\">reject</span>(err)\n      }\n    }\n  }</pre></div>\n<h2>四、总结</h2>\n<ol>\n<li>Koa这个框架是小而精美的，它的源码是也非常少，只有一千多行。中间件的执行机制主要是读懂这个koa-compose的代码，多个中间件会形成一个<code>先进后出</code>的栈结构，当前中间件掌握下一个中间件的执行权。</li>\n<li>Koa本身的功能可能是满足不了我们日常开发的需求的，我们可以通过许多的第三方的包，也可以自定义中间件来辅助我们的开发。（了解了中间件机制，自定义一个中间件就非常容易了）</li>\n<li><code>Koa1</code>借助<code>co</code> and <code>generator</code>管理我们的中间件，<code>Koa2</code>借助<code>async await</code>（async函数返回的是<code>Promise</code>对象）管理我们的中间件。</li>\n</ol>\n<h3>五、参考文档</h3>\n<ol>\n<li><a href=\"https://zhuanlan.zhihu.com/p/33316664\" rel=\"nofollow\">Koa2 还有多久取代 Express</a></li>\n<li><a href=\"https://blog.csdn.net/zramals/article/details/80653715\" rel=\"nofollow\">Koa vs Express && Koa1 vs Koa2</a></li>\n</ol>\n      </td>\n    </tr>\n  </tbody>\n</table>",
      "title": "Koa源码分析（中间件执行机制、Koa2与Koa1比较)",
      "time": "2020-01-01"
    },
    {
      "html": "<table class=\"d-block\" data-paste-markdown-skip>\n  <tbody class=\"d-block\">\n    <tr class=\"d-block\">\n      <td class=\"d-block comment-body markdown-body  js-comment-body\">\n          <h2>一、why Koa</h2>\n<ol>\n<li><code>Koa</code>是由<code>Express</code>原班人马打造，但是相较于<code>Express</code>的大而全，<code>Koa</code>是小而精的。<code>Koa</code>没有绑定很多的框架以及插件，更容易让我们进行扩展，包括现在较为流行的<code>EggJS</code> and <code>ThinkJS</code>都是基于<code>Koa</code>开发的。</li>\n<li><code>Koa</code>避免了Express中间件基于callback形式的调用，它使用了我们JS新版本特性，<code>Koa1</code>中间件借助于我们的<code>co</code> and <code>generator</code>特性，<code>Koa2</code>借助了<code>Promise</code> and <code>async await</code>特性，更好的进行流程控制以及catch我们的错误。</li>\n<li><code>Koa</code>提供了<code>Context</code>对象，实际上是对我们node中<code>request</code> and <code>response</code>对象的封装，我们不需要很多的手动处理我们的<code>request</code> and <code>response</code>对象。<code>Context</code>是贯穿我们整个请求的过程，我们可以中间件需要传递参数挂在到<code>Context</code>对象上。（栗子：我们可以将用户信息挂在它上面，通过<code>ctx.state.user</code>进行操作。）</li>\n<li><code>Koa</code>的中间件执行机制：<code>洋葱圈模型</code>。它不是按顺序执行的，多个中间件会形成一个<code>先进后出</code>的栈结构，当前中间件掌握下一个中间件的执行权，对于流程控制以及后置处理逻辑的实现非常有效。</li>\n</ol>\n<h2>二、Koa2与Koa1的比较</h2>\n<ol>\n<li>中间件的管理方式：<code>Koa1</code>借助<code>co</code> and <code>generator</code>管理我们的中间件，<code>Koa2</code>借助<code>async await</code>（async函数返回的是<code>Promise</code>对象）管理我们的中间件。</li>\n<li><code>context</code>对象获取：<code>Koa1</code>通过<code>this</code>对象（<code>this.req</code>,<code>this.res</code>）获取，<code>Koa2</code>通过<code>ctx</code>参数（<code>ctx.req</code>, <code>ctx.res</code>）获取。</li>\n<li><code>Koa2</code>的轮子多且成熟，生态比<code>Koa1</code>丰富。</li>\n</ol>\n<h2>三、举个栗子，剖析源码</h2>\n<h3>1. 栗子</h3>\n<p><a target=\"_blank\" rel=\"noopener noreferrer\" href=\"https://camo.githubusercontent.com/b4390ee94df94f96610941a183d70ea13aaba2ae/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323031392f706e672f3637363630302f313537373735353539393033312d61303663626330622d386333612d343166622d623939662d3962666266643964333561312e706e6723616c69676e3d6c65667426646973706c61793d696e6c696e65266865696768743d353133266e616d653d696d6167652e706e67266f726967696e4865696768743d353133266f726967696e57696474683d3438332673697a653d3533373736267374617475733d646f6e65267374796c653d6e6f6e652677696474683d343833\"><img src=\"https://camo.githubusercontent.com/b4390ee94df94f96610941a183d70ea13aaba2ae/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323031392f706e672f3637363630302f313537373735353539393033312d61303663626330622d386333612d343166622d623939662d3962666266643964333561312e706e6723616c69676e3d6c65667426646973706c61793d696e6c696e65266865696768743d353133266e616d653d696d6167652e706e67266f726967696e4865696768743d353133266f726967696e57696474683d3438332673697a653d3533373736267374617475733d646f6e65267374796c653d6e6f6e652677696474683d343833\" alt=\"image.png\" data-canonical-src=\"https://cdn.nlark.com/yuque/0/2019/png/676600/1577755599031-a06cbc0b-8c3a-41fb-b99f-9bfbfd9d35a1.png#align=left&display=inline&height=513&name=image.png&originHeight=513&originWidth=483&size=53776&status=done&style=none&width=483\" style=\"max-width:100%;\"></a><br>\n这段代码呢，通过<code>listen</code>方法创建了我们的http服务器，端口是<code>3000</code>。并且通过<code>use</code>方法传入了三个<code>koa</code>中间件, 并且<code>console</code>出我们的执行结果。</p>\n<h3>2. 从<code>listen</code>方法说起</h3>\n<ol>\n<li>首先我们去github上clone最新的<a href=\"https://github.com/koajs/koa\">Koa</a>的源代码。然后源码结构如下：</li>\n</ol>\n<p><a target=\"_blank\" rel=\"noopener noreferrer\" href=\"https://camo.githubusercontent.com/321c954731ac3367b9cd4c05c9cd46e066939499/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323031392f706e672f3637363630302f313537373735353633333636372d32626434663631612d643533322d343336302d396164312d3937363262383131396130392e706e6723616c69676e3d6c65667426646973706c61793d696e6c696e65266865696768743d353332266e616d653d696d6167652e706e67266f726967696e4865696768743d353332266f726967696e57696474683d3332362673697a653d3332313338267374617475733d646f6e65267374796c653d6e6f6e652677696474683d333236\"><img src=\"https://camo.githubusercontent.com/321c954731ac3367b9cd4c05c9cd46e066939499/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323031392f706e672f3637363630302f313537373735353633333636372d32626434663631612d643533322d343336302d396164312d3937363262383131396130392e706e6723616c69676e3d6c65667426646973706c61793d696e6c696e65266865696768743d353332266e616d653d696d6167652e706e67266f726967696e4865696768743d353332266f726967696e57696474683d3332362673697a653d3332313338267374617475733d646f6e65267374796c653d6e6f6e652677696474683d333236\" alt=\"image.png\" data-canonical-src=\"https://cdn.nlark.com/yuque/0/2019/png/676600/1577755633667-2bd4f61a-d532-4360-9ad1-9762b8119a09.png#align=left&display=inline&height=532&name=image.png&originHeight=532&originWidth=326&size=32138&status=done&style=none&width=326\" style=\"max-width:100%;\"></a></p>\n<ol start=\"2\">\n<li>可以看得出来整个源码的核心代码皆在<code>lib</code>文件，我们在栗子中<code>require('koa')</code>实际上是引入的<code>lib/application.js</code>里面的<code>Application</code>类。下面我们来分析一下我们的<code>listen</code>方法的实现，首先我们看一下这个<code>Application</code>类里面到底有些什么：</li>\n</ol>\n<p><a target=\"_blank\" rel=\"noopener noreferrer\" href=\"https://camo.githubusercontent.com/50bd64e5511e6fc0c4f776a1c75b91a0bab3e1aa/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323031392f706e672f3637363630302f313537373735363833323633342d33356261393936612d363734322d343433332d616239332d3335373537353038653536382e706e6723616c69676e3d6c65667426646973706c61793d696e6c696e65266865696768743d363136266e616d653d696d6167652e706e67266f726967696e4865696768743d363136266f726967696e57696474683d3632312673697a653d3534303830267374617475733d646f6e65267374796c653d6e6f6e652677696474683d363231\"><img src=\"https://camo.githubusercontent.com/50bd64e5511e6fc0c4f776a1c75b91a0bab3e1aa/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323031392f706e672f3637363630302f313537373735363833323633342d33356261393936612d363734322d343433332d616239332d3335373537353038653536382e706e6723616c69676e3d6c65667426646973706c61793d696e6c696e65266865696768743d363136266e616d653d696d6167652e706e67266f726967696e4865696768743d363136266f726967696e57696474683d3632312673697a653d3534303830267374617475733d646f6e65267374796c653d6e6f6e652677696474683d363231\" alt=\"image.png\" data-canonical-src=\"https://cdn.nlark.com/yuque/0/2019/png/676600/1577756832634-35ba996a-6742-4433-ab93-35757508e568.png#align=left&display=inline&height=616&name=image.png&originHeight=616&originWidth=621&size=54080&status=done&style=none&width=621\" style=\"max-width:100%;\"></a></p>\n<ol start=\"3\">\n<li>我们可以看到<code>Application</code>类下有我们的<code>listen</code>方法，方法如下：</li>\n</ol>\n<p><a target=\"_blank\" rel=\"noopener noreferrer\" href=\"https://camo.githubusercontent.com/cf17936cf0b4683d6c063323fae10876e45eae6e/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323031392f706e672f3637363630302f313537373735363933353037322d64393036383361362d326462352d343061612d386535642d3130316664613532653330612e706e6723616c69676e3d6c65667426646973706c61793d696e6c696e65266865696768743d313231266e616d653d696d6167652e706e67266f726967696e4865696768743d313231266f726967696e57696474683d3439322673697a653d3134343339267374617475733d646f6e65267374796c653d6e6f6e652677696474683d343932\"><img src=\"https://camo.githubusercontent.com/cf17936cf0b4683d6c063323fae10876e45eae6e/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323031392f706e672f3637363630302f313537373735363933353037322d64393036383361362d326462352d343061612d386535642d3130316664613532653330612e706e6723616c69676e3d6c65667426646973706c61793d696e6c696e65266865696768743d313231266e616d653d696d6167652e706e67266f726967696e4865696768743d313231266f726967696e57696474683d3439322673697a653d3134343339267374617475733d646f6e65267374796c653d6e6f6e652677696474683d343932\" alt=\"image.png\" data-canonical-src=\"https://cdn.nlark.com/yuque/0/2019/png/676600/1577756935072-d90683a6-2db5-40aa-8e5d-101fda52e30a.png#align=left&display=inline&height=121&name=image.png&originHeight=121&originWidth=492&size=14439&status=done&style=none&width=492\" style=\"max-width:100%;\"></a><br>\n可以看出这里实际上还是通过我们Node.js的http模块，通过createServer创建一个http服务器, 然后listen方法接收我们的端口，这和我们使用原生Node.js创建一个http服务器是一样的。这个this.callback()也就是我们createServer的入参，这个参数是一个函数，是 作为 request 事件的监听函数，这个函数还接收两个参数req、res，也就是我们的请求对象以及响应对象。那我们可以推断出这个<code>listen</code>方法里面的<code>this.callback()</code>实际上也返回是一个函数，这个函数接收req、res两个入参。</p>\n<ol start=\"4\">\n<li>接下来我们再看一下这个<code>this.callback()</code>里的callback方法是啥样的：</li>\n</ol>\n<p><a target=\"_blank\" rel=\"noopener noreferrer\" href=\"https://camo.githubusercontent.com/176b92d3298a6bacc37390ecf7b6caf9d0b2d2e2/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323031392f706e672f3637363630302f313537373735373730373437342d36643163323563642d356666662d343133342d616138352d6662313365326264626432382e706e6723616c69676e3d6c65667426646973706c61793d696e6c696e65266865696768743d323631266e616d653d696d6167652e706e67266f726967696e4865696768743d323631266f726967696e57696474683d3632362673697a653d3333393435267374617475733d646f6e65267374796c653d6e6f6e652677696474683d363236\"><img src=\"https://camo.githubusercontent.com/176b92d3298a6bacc37390ecf7b6caf9d0b2d2e2/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323031392f706e672f3637363630302f313537373735373730373437342d36643163323563642d356666662d343133342d616138352d6662313365326264626432382e706e6723616c69676e3d6c65667426646973706c61793d696e6c696e65266865696768743d323631266e616d653d696d6167652e706e67266f726967696e4865696768743d323631266f726967696e57696474683d3632362673697a653d3333393435267374617475733d646f6e65267374796c653d6e6f6e652677696474683d363236\" alt=\"image.png\" data-canonical-src=\"https://cdn.nlark.com/yuque/0/2019/png/676600/1577757707474-6d1c25cd-5fff-4134-aa85-fb13e2bdbd28.png#align=left&display=inline&height=261&name=image.png&originHeight=261&originWidth=626&size=33945&status=done&style=none&width=626\" style=\"max-width:100%;\"></a><br>\ncallback方法内的第一句fn = compose(this.middleware)，这个this.middleware是我们在Application类中的constructor就定义了，是一个数组，这里实际上存储的就是我们举的栗子中的app.use（）的入参方法，也就是我们Koa的中间件。这个compose方法很重要，主要是控制我们的中间件的执行，下文讲中间件的执行机制会仔细说说这个compose。然后看这个函数返回，果然和我们推断的一样，这个callback方法最终返回的是一个handleRequest方法，接收req，res两个参数。handleRequest方法中，第一句this.createContext方法实际上就是对我们req、res对象的封装：<br>\n<a target=\"_blank\" rel=\"noopener noreferrer\" href=\"https://camo.githubusercontent.com/37944de2d69671d2a30bd0bc2eb358af36bfc485/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323031392f706e672f3637363630302f313537373737363139313833332d31343139653834642d636633662d346164362d393437652d6661653535333534666636392e706e6723616c69676e3d6c65667426646973706c61793d696e6c696e65266865696768743d333034266e616d653d696d6167652e706e67266f726967696e4865696768743d333034266f726967696e57696474683d3633342673697a653d3535303632267374617475733d646f6e65267374796c653d6e6f6e652677696474683d363334\"><img src=\"https://camo.githubusercontent.com/37944de2d69671d2a30bd0bc2eb358af36bfc485/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323031392f706e672f3637363630302f313537373737363139313833332d31343139653834642d636633662d346164362d393437652d6661653535333534666636392e706e6723616c69676e3d6c65667426646973706c61793d696e6c696e65266865696768743d333034266e616d653d696d6167652e706e67266f726967696e4865696768743d333034266f726967696e57696474683d3633342673697a653d3535303632267374617475733d646f6e65267374796c653d6e6f6e652677696474683d363334\" alt=\"image.png\" data-canonical-src=\"https://cdn.nlark.com/yuque/0/2019/png/676600/1577776191833-1419e84d-cf3f-4ad6-947e-fae55354ff69.png#align=left&display=inline&height=304&name=image.png&originHeight=304&originWidth=634&size=55062&status=done&style=none&width=634\" style=\"max-width:100%;\"></a><br>\n通过createContext 创建了我们ctx对象。这个callback方法返回的handleRequest方法第二句是返回了Application类上的handleRequest方法的执行结果（注意这里有“重名”的方法，注意区分），方法如下：<br>\n<a target=\"_blank\" rel=\"noopener noreferrer\" href=\"https://camo.githubusercontent.com/3aa0e9f882243e7b67072a57fe98a88a7745e983/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323031392f706e672f3637363630302f313537373737373336363239332d66646566653063612d383436362d346565312d393263622d6330343935326263303330612e706e6723616c69676e3d6c65667426646973706c61793d696e6c696e65266865696768743d313935266e616d653d696d6167652e706e67266f726967696e4865696768743d313935266f726967696e57696474683d3634332673697a653d3339363533267374617475733d646f6e65267374796c653d6e6f6e652677696474683d363433\"><img src=\"https://camo.githubusercontent.com/3aa0e9f882243e7b67072a57fe98a88a7745e983/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323031392f706e672f3637363630302f313537373737373336363239332d66646566653063612d383436362d346565312d393263622d6330343935326263303330612e706e6723616c69676e3d6c65667426646973706c61793d696e6c696e65266865696768743d313935266e616d653d696d6167652e706e67266f726967696e4865696768743d313935266f726967696e57696474683d3634332673697a653d3339363533267374617475733d646f6e65267374796c653d6e6f6e652677696474683d363433\" alt=\"image.png\" data-canonical-src=\"https://cdn.nlark.com/yuque/0/2019/png/676600/1577777366293-fdefe0ca-8466-4ee1-92cb-c04952bc030a.png#align=left&display=inline&height=195&name=image.png&originHeight=195&originWidth=643&size=39653&status=done&style=none&width=643\" style=\"max-width:100%;\"></a></p>\n<p>这个方法接收两个参数: 我们的compose的返回结果fn、ctx对象，主要是对我们请求的处理以及错误的统一捕获以及处理。</p>\n<h3>3. 执行一下我们的栗子：扒一扒中间件的执行机制</h3>\n<p>Koa的中间件执行机制有个形象的称呼-洋葱圈模型。我们先执行栗子代码，看看输出的结果到底是什么？<br>\n    <a target=\"_blank\" rel=\"noopener noreferrer\" href=\"https://camo.githubusercontent.com/44ca564a6bfb6b968e69413974297c386450292c/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323031392f706e672f3637363630302f313537373737383235323837332d33306264613436642d616632382d343264612d383137632d6536643532376561346539652e706e6723616c69676e3d6c65667426646973706c61793d696e6c696e65266865696768743d313036266e616d653d696d6167652e706e67266f726967696e4865696768743d313036266f726967696e57696474683d3239392673697a653d34353234267374617475733d646f6e65267374796c653d6e6f6e652677696474683d323939\"><img src=\"https://camo.githubusercontent.com/44ca564a6bfb6b968e69413974297c386450292c/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323031392f706e672f3637363630302f313537373737383235323837332d33306264613436642d616632382d343264612d383137632d6536643532376561346539652e706e6723616c69676e3d6c65667426646973706c61793d696e6c696e65266865696768743d313036266e616d653d696d6167652e706e67266f726967696e4865696768743d313036266f726967696e57696474683d3239392673697a653d34353234267374617475733d646f6e65267374796c653d6e6f6e652677696474683d323939\" alt=\"image.png\" data-canonical-src=\"https://cdn.nlark.com/yuque/0/2019/png/676600/1577778252873-30bda46d-af28-42da-817c-e6d527ea4e9e.png#align=left&display=inline&height=106&name=image.png&originHeight=106&originWidth=299&size=4524&status=done&style=none&width=299\" style=\"max-width:100%;\"></a></p>\n<h5>从use方法说起</h5>\n<p><a target=\"_blank\" rel=\"noopener noreferrer\" href=\"https://camo.githubusercontent.com/5e2a08feb193b97fa1f13ee462777b9dc97649b8/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323031392f706e672f3637363630302f313537373737383335363433392d36383932616234662d346566382d346239632d623762652d6232653436316262383333372e706e6723616c69676e3d6c65667426646973706c61793d696e6c696e65266865696768743d323639266e616d653d696d6167652e706e67266f726967696e4865696768743d323639266f726967696e57696474683d3738372673697a653d3433393536267374617475733d646f6e65267374796c653d6e6f6e652677696474683d373837\"><img src=\"https://camo.githubusercontent.com/5e2a08feb193b97fa1f13ee462777b9dc97649b8/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323031392f706e672f3637363630302f313537373737383335363433392d36383932616234662d346566382d346239632d623762652d6232653436316262383333372e706e6723616c69676e3d6c65667426646973706c61793d696e6c696e65266865696768743d323639266e616d653d696d6167652e706e67266f726967696e4865696768743d323639266f726967696e57696474683d3738372673697a653d3433393536267374617475733d646f6e65267374796c653d6e6f6e652677696474683d373837\" alt=\"image.png\" data-canonical-src=\"https://cdn.nlark.com/yuque/0/2019/png/676600/1577778356439-6892ab4f-4ef8-4b9c-b7be-b2e461bb8337.png#align=left&display=inline&height=269&name=image.png&originHeight=269&originWidth=787&size=43956&status=done&style=none&width=787\" style=\"max-width:100%;\"></a><br>\napp.use实际上就是调用了Applcation类下面的use方法，这个方法主要是先判断入参形式是否是一个函数等（参数校验），如果入参是一个generator函数，这也就是koa1中的写法，在koa2中需要koa-convert去转换一下。然后将我们入参传入的中间件函数push到this.middleware数组中。<br>\n再回到上文提到的callback函数，我们的中间件执行机制的核心就是compose(this.middleware),下面我们来分析一下compose函数的源码：<br>\n<a target=\"_blank\" rel=\"noopener noreferrer\" href=\"https://camo.githubusercontent.com/8f9c713e436d0a88c29b050490e83b5787fe80a3/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323031392f706e672f3637363630302f313537373738333238303038352d37373063393937642d623361312d346139332d613238612d3131343036303234376561662e706e6723616c69676e3d6c65667426646973706c61793d696e6c696e65266865696768743d363432266e616d653d696d6167652e706e67266f726967696e4865696768743d363432266f726967696e57696474683d3839322673697a653d3931323330267374617475733d646f6e65267374796c653d6e6f6e652677696474683d383932\"><img src=\"https://camo.githubusercontent.com/8f9c713e436d0a88c29b050490e83b5787fe80a3/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323031392f706e672f3637363630302f313537373738333238303038352d37373063393937642d623361312d346139332d613238612d3131343036303234376561662e706e6723616c69676e3d6c65667426646973706c61793d696e6c696e65266865696768743d363432266e616d653d696d6167652e706e67266f726967696e4865696768743d363432266f726967696e57696474683d3839322673697a653d3931323330267374617475733d646f6e65267374796c653d6e6f6e652677696474683d383932\" alt=\"image.png\" data-canonical-src=\"https://cdn.nlark.com/yuque/0/2019/png/676600/1577783280085-770c997d-b3a1-4a93-a28a-114060247eaf.png#align=left&display=inline&height=642&name=image.png&originHeight=642&originWidth=892&size=91230&status=done&style=none&width=892\" style=\"max-width:100%;\"></a></p>\n<ol>\n<li>先校验我们middleware的参数正确性，是否是数组，数组项是否为函数；</li>\n<li>compose函数实际上是返回一个function，这个返回的function，在上面也提及，最终是传入到handleRequest方法中然后传入ctx参数：fnMiddleware(context)。</li>\n<li>再回到我们的compose中return的这个function，接收两个参数：第一个就是我们handleRequest方法传入的ctx对象，第二个next呢，实际上是传入的一个方法，这个方法是在所有middleware执行完毕后，最后执行处理的函数。这个function核心就是递归执行我们的middleware。要理解这段代码，先要理解<code>Promise.reslove()</code>。</li>\n</ol>\n<div class=\"highlight highlight-source-js\"><pre><span class=\"pl-c\"><span class=\"pl-c\">//</span> Promise.reslove返回一个fulfillled状态的promise对象</span>\n<span class=\"pl-c\"><span class=\"pl-c\">//</span> 可以看成new Promise()的快捷方式</span>\n\n<span class=\"pl-c1\">Promise</span>.<span class=\"pl-en\">reslove</span>(<span class=\"pl-en\">fn</span>(context, <span class=\"pl-smi\">dispatch</span>.<span class=\"pl-en\">bind</span>(<span class=\"pl-c1\">null</span>, i<span class=\"pl-k\">+</span><span class=\"pl-c1\">1</span>)))；\n<span class=\"pl-c\"><span class=\"pl-c\">//</span> 实际上是等于</span>\n<span class=\"pl-k\">new</span> <span class=\"pl-en\">Promise</span>((<span class=\"pl-smi\">relove</span>, <span class=\"pl-smi\">reject</span>) <span class=\"pl-k\">=></span> {\n  <span class=\"pl-en\">reslove</span>(<span class=\"pl-en\">fn</span>(context, <span class=\"pl-smi\">dispatch</span>.<span class=\"pl-en\">bind</span>(<span class=\"pl-c1\">null</span>, i<span class=\"pl-k\">+</span><span class=\"pl-c1\">1</span>)));\n})</pre></div>\n<ol start=\"4\">\n<li>仔细阅读这个function, 它是先定义了一个index（利用我们的闭包每次执行一次dispatch方法去改变index），执行了dispatch(0),这个dispatch方法就是我们执行机制的实现，dispatch函数里面如果没有执行到最后一个middleware，就返回了<code>Promise.reslove(fn(context, dispatch.bind(null, i + 1)))</code>, 这个<code>fn(context, dispatch.bind(null, i + 1))</code>也就是执行我们通过<code>app.use</code>加入的middleware函数，middleware函数统一接收两个参数一个是context，一个是next：下一个middleware函数，这样可以看出来如果我们koa中某个中间件没有执行next方法，那么之后加入的中间件是不会执行的。这也就形成了我们的<code>洋葱圈模型</code>。</li>\n</ol>\n<div class=\"highlight highlight-source-js\"><pre><span class=\"pl-c\"><span class=\"pl-c\">//</span> 核心方法：递归调用我们middlewares, 基于Promise进行异步流程控制；</span>\n<span class=\"pl-c\"><span class=\"pl-c\">//</span> Promise.resolve()返回的是一个thenable对象；</span>\n<span class=\"pl-c\"><span class=\"pl-c\">//</span> 所以我们koa2中中间件都基于async函数，await等待下个中间件方法的执行；</span>\n<span class=\"pl-k\">return</span> <span class=\"pl-k\">function</span> (<span class=\"pl-smi\">context</span>, <span class=\"pl-smi\">next</span>) {\n    <span class=\"pl-c\"><span class=\"pl-c\">//</span> last called middleware #</span>\n    <span class=\"pl-k\">let</span> index <span class=\"pl-k\">=</span> <span class=\"pl-k\">-</span><span class=\"pl-c1\">1</span>\n    <span class=\"pl-k\">return</span> <span class=\"pl-en\">dispatch</span>(<span class=\"pl-c1\">0</span>)\n    <span class=\"pl-k\">function</span> <span class=\"pl-en\">dispatch</span> (<span class=\"pl-smi\">i</span>) {\n      <span class=\"pl-k\">if</span> (i <span class=\"pl-k\"><=</span> index) <span class=\"pl-k\">return</span> <span class=\"pl-c1\">Promise</span>.<span class=\"pl-c1\">reject</span>(<span class=\"pl-k\">new</span> <span class=\"pl-en\">Error</span>(<span class=\"pl-s\"><span class=\"pl-pds\">'</span>next() called multiple times<span class=\"pl-pds\">'</span></span>))\n      index <span class=\"pl-k\">=</span> i\n      <span class=\"pl-k\">let</span> fn <span class=\"pl-k\">=</span> middleware[i]\n      <span class=\"pl-k\">if</span> (i <span class=\"pl-k\">===</span> <span class=\"pl-smi\">middleware</span>.<span class=\"pl-c1\">length</span>) fn <span class=\"pl-k\">=</span> next\n      <span class=\"pl-k\">if</span> (<span class=\"pl-k\">!</span>fn) <span class=\"pl-k\">return</span> <span class=\"pl-c1\">Promise</span>.<span class=\"pl-c1\">resolve</span>()\n      <span class=\"pl-k\">try</span> {\n        <span class=\"pl-k\">return</span> <span class=\"pl-c1\">Promise</span>.<span class=\"pl-c1\">resolve</span>(<span class=\"pl-en\">fn</span>(context, <span class=\"pl-smi\">dispatch</span>.<span class=\"pl-en\">bind</span>(<span class=\"pl-c1\">null</span>, i <span class=\"pl-k\">+</span> <span class=\"pl-c1\">1</span>)));\n      } <span class=\"pl-k\">catch</span> (err) {\n        <span class=\"pl-k\">return</span> <span class=\"pl-c1\">Promise</span>.<span class=\"pl-c1\">reject</span>(err)\n      }\n    }\n  }</pre></div>\n<h2>四、总结</h2>\n<ol>\n<li>Koa这个框架是小而精美的，它的源码是也非常少，只有一千多行。中间件的执行机制主要是读懂这个koa-compose的代码，多个中间件会形成一个<code>先进后出</code>的栈结构，当前中间件掌握下一个中间件的执行权。</li>\n<li>Koa本身的功能可能是满足不了我们日常开发的需求的，我们可以通过许多的第三方的包，也可以自定义中间件来辅助我们的开发。（了解了中间件机制，自定义一个中间件就非常容易了）</li>\n<li><code>Koa1</code>借助<code>co</code> and <code>generator</code>管理我们的中间件，<code>Koa2</code>借助<code>async await</code>（async函数返回的是<code>Promise</code>对象）管理我们的中间件。</li>\n</ol>\n<h3>五、参考文档</h3>\n<ol>\n<li><a href=\"https://zhuanlan.zhihu.com/p/33316664\" rel=\"nofollow\">Koa2 还有多久取代 Express</a></li>\n<li><a href=\"https://blog.csdn.net/zramals/article/details/80653715\" rel=\"nofollow\">Koa vs Express && Koa1 vs Koa2</a></li>\n</ol>\n      </td>\n    </tr>\n  </tbody>\n</table>",
      "title": "Koa源码分析（中间件执行机制、Koa2与Koa1比较)",
      "time": "2020-01-01"
    },
    {
      "html": "<table class=\"d-block\" data-paste-markdown-skip>\n  <tbody class=\"d-block\">\n    <tr class=\"d-block\">\n      <td class=\"d-block comment-body markdown-body  js-comment-body\">\n          <h2>一、why Koa</h2>\n<ol>\n<li><code>Koa</code>是由<code>Express</code>原班人马打造，但是相较于<code>Express</code>的大而全，<code>Koa</code>是小而精的。<code>Koa</code>没有绑定很多的框架以及插件，更容易让我们进行扩展，包括现在较为流行的<code>EggJS</code> and <code>ThinkJS</code>都是基于<code>Koa</code>开发的。</li>\n<li><code>Koa</code>避免了Express中间件基于callback形式的调用，它使用了我们JS新版本特性，<code>Koa1</code>中间件借助于我们的<code>co</code> and <code>generator</code>特性，<code>Koa2</code>借助了<code>Promise</code> and <code>async await</code>特性，更好的进行流程控制以及catch我们的错误。</li>\n<li><code>Koa</code>提供了<code>Context</code>对象，实际上是对我们node中<code>request</code> and <code>response</code>对象的封装，我们不需要很多的手动处理我们的<code>request</code> and <code>response</code>对象。<code>Context</code>是贯穿我们整个请求的过程，我们可以中间件需要传递参数挂在到<code>Context</code>对象上。（栗子：我们可以将用户信息挂在它上面，通过<code>ctx.state.user</code>进行操作。）</li>\n<li><code>Koa</code>的中间件执行机制：<code>洋葱圈模型</code>。它不是按顺序执行的，多个中间件会形成一个<code>先进后出</code>的栈结构，当前中间件掌握下一个中间件的执行权，对于流程控制以及后置处理逻辑的实现非常有效。</li>\n</ol>\n<h2>二、Koa2与Koa1的比较</h2>\n<ol>\n<li>中间件的管理方式：<code>Koa1</code>借助<code>co</code> and <code>generator</code>管理我们的中间件，<code>Koa2</code>借助<code>async await</code>（async函数返回的是<code>Promise</code>对象）管理我们的中间件。</li>\n<li><code>context</code>对象获取：<code>Koa1</code>通过<code>this</code>对象（<code>this.req</code>,<code>this.res</code>）获取，<code>Koa2</code>通过<code>ctx</code>参数（<code>ctx.req</code>, <code>ctx.res</code>）获取。</li>\n<li><code>Koa2</code>的轮子多且成熟，生态比<code>Koa1</code>丰富。</li>\n</ol>\n<h2>三、举个栗子，剖析源码</h2>\n<h3>1. 栗子</h3>\n<p><a target=\"_blank\" rel=\"noopener noreferrer\" href=\"https://camo.githubusercontent.com/b4390ee94df94f96610941a183d70ea13aaba2ae/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323031392f706e672f3637363630302f313537373735353539393033312d61303663626330622d386333612d343166622d623939662d3962666266643964333561312e706e6723616c69676e3d6c65667426646973706c61793d696e6c696e65266865696768743d353133266e616d653d696d6167652e706e67266f726967696e4865696768743d353133266f726967696e57696474683d3438332673697a653d3533373736267374617475733d646f6e65267374796c653d6e6f6e652677696474683d343833\"><img src=\"https://camo.githubusercontent.com/b4390ee94df94f96610941a183d70ea13aaba2ae/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323031392f706e672f3637363630302f313537373735353539393033312d61303663626330622d386333612d343166622d623939662d3962666266643964333561312e706e6723616c69676e3d6c65667426646973706c61793d696e6c696e65266865696768743d353133266e616d653d696d6167652e706e67266f726967696e4865696768743d353133266f726967696e57696474683d3438332673697a653d3533373736267374617475733d646f6e65267374796c653d6e6f6e652677696474683d343833\" alt=\"image.png\" data-canonical-src=\"https://cdn.nlark.com/yuque/0/2019/png/676600/1577755599031-a06cbc0b-8c3a-41fb-b99f-9bfbfd9d35a1.png#align=left&display=inline&height=513&name=image.png&originHeight=513&originWidth=483&size=53776&status=done&style=none&width=483\" style=\"max-width:100%;\"></a><br>\n这段代码呢，通过<code>listen</code>方法创建了我们的http服务器，端口是<code>3000</code>。并且通过<code>use</code>方法传入了三个<code>koa</code>中间件, 并且<code>console</code>出我们的执行结果。</p>\n<h3>2. 从<code>listen</code>方法说起</h3>\n<ol>\n<li>首先我们去github上clone最新的<a href=\"https://github.com/koajs/koa\">Koa</a>的源代码。然后源码结构如下：</li>\n</ol>\n<p><a target=\"_blank\" rel=\"noopener noreferrer\" href=\"https://camo.githubusercontent.com/321c954731ac3367b9cd4c05c9cd46e066939499/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323031392f706e672f3637363630302f313537373735353633333636372d32626434663631612d643533322d343336302d396164312d3937363262383131396130392e706e6723616c69676e3d6c65667426646973706c61793d696e6c696e65266865696768743d353332266e616d653d696d6167652e706e67266f726967696e4865696768743d353332266f726967696e57696474683d3332362673697a653d3332313338267374617475733d646f6e65267374796c653d6e6f6e652677696474683d333236\"><img src=\"https://camo.githubusercontent.com/321c954731ac3367b9cd4c05c9cd46e066939499/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323031392f706e672f3637363630302f313537373735353633333636372d32626434663631612d643533322d343336302d396164312d3937363262383131396130392e706e6723616c69676e3d6c65667426646973706c61793d696e6c696e65266865696768743d353332266e616d653d696d6167652e706e67266f726967696e4865696768743d353332266f726967696e57696474683d3332362673697a653d3332313338267374617475733d646f6e65267374796c653d6e6f6e652677696474683d333236\" alt=\"image.png\" data-canonical-src=\"https://cdn.nlark.com/yuque/0/2019/png/676600/1577755633667-2bd4f61a-d532-4360-9ad1-9762b8119a09.png#align=left&display=inline&height=532&name=image.png&originHeight=532&originWidth=326&size=32138&status=done&style=none&width=326\" style=\"max-width:100%;\"></a></p>\n<ol start=\"2\">\n<li>可以看得出来整个源码的核心代码皆在<code>lib</code>文件，我们在栗子中<code>require('koa')</code>实际上是引入的<code>lib/application.js</code>里面的<code>Application</code>类。下面我们来分析一下我们的<code>listen</code>方法的实现，首先我们看一下这个<code>Application</code>类里面到底有些什么：</li>\n</ol>\n<p><a target=\"_blank\" rel=\"noopener noreferrer\" href=\"https://camo.githubusercontent.com/50bd64e5511e6fc0c4f776a1c75b91a0bab3e1aa/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323031392f706e672f3637363630302f313537373735363833323633342d33356261393936612d363734322d343433332d616239332d3335373537353038653536382e706e6723616c69676e3d6c65667426646973706c61793d696e6c696e65266865696768743d363136266e616d653d696d6167652e706e67266f726967696e4865696768743d363136266f726967696e57696474683d3632312673697a653d3534303830267374617475733d646f6e65267374796c653d6e6f6e652677696474683d363231\"><img src=\"https://camo.githubusercontent.com/50bd64e5511e6fc0c4f776a1c75b91a0bab3e1aa/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323031392f706e672f3637363630302f313537373735363833323633342d33356261393936612d363734322d343433332d616239332d3335373537353038653536382e706e6723616c69676e3d6c65667426646973706c61793d696e6c696e65266865696768743d363136266e616d653d696d6167652e706e67266f726967696e4865696768743d363136266f726967696e57696474683d3632312673697a653d3534303830267374617475733d646f6e65267374796c653d6e6f6e652677696474683d363231\" alt=\"image.png\" data-canonical-src=\"https://cdn.nlark.com/yuque/0/2019/png/676600/1577756832634-35ba996a-6742-4433-ab93-35757508e568.png#align=left&display=inline&height=616&name=image.png&originHeight=616&originWidth=621&size=54080&status=done&style=none&width=621\" style=\"max-width:100%;\"></a></p>\n<ol start=\"3\">\n<li>我们可以看到<code>Application</code>类下有我们的<code>listen</code>方法，方法如下：</li>\n</ol>\n<p><a target=\"_blank\" rel=\"noopener noreferrer\" href=\"https://camo.githubusercontent.com/cf17936cf0b4683d6c063323fae10876e45eae6e/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323031392f706e672f3637363630302f313537373735363933353037322d64393036383361362d326462352d343061612d386535642d3130316664613532653330612e706e6723616c69676e3d6c65667426646973706c61793d696e6c696e65266865696768743d313231266e616d653d696d6167652e706e67266f726967696e4865696768743d313231266f726967696e57696474683d3439322673697a653d3134343339267374617475733d646f6e65267374796c653d6e6f6e652677696474683d343932\"><img src=\"https://camo.githubusercontent.com/cf17936cf0b4683d6c063323fae10876e45eae6e/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323031392f706e672f3637363630302f313537373735363933353037322d64393036383361362d326462352d343061612d386535642d3130316664613532653330612e706e6723616c69676e3d6c65667426646973706c61793d696e6c696e65266865696768743d313231266e616d653d696d6167652e706e67266f726967696e4865696768743d313231266f726967696e57696474683d3439322673697a653d3134343339267374617475733d646f6e65267374796c653d6e6f6e652677696474683d343932\" alt=\"image.png\" data-canonical-src=\"https://cdn.nlark.com/yuque/0/2019/png/676600/1577756935072-d90683a6-2db5-40aa-8e5d-101fda52e30a.png#align=left&display=inline&height=121&name=image.png&originHeight=121&originWidth=492&size=14439&status=done&style=none&width=492\" style=\"max-width:100%;\"></a><br>\n可以看出这里实际上还是通过我们Node.js的http模块，通过createServer创建一个http服务器, 然后listen方法接收我们的端口，这和我们使用原生Node.js创建一个http服务器是一样的。这个this.callback()也就是我们createServer的入参，这个参数是一个函数，是 作为 request 事件的监听函数，这个函数还接收两个参数req、res，也就是我们的请求对象以及响应对象。那我们可以推断出这个<code>listen</code>方法里面的<code>this.callback()</code>实际上也返回是一个函数，这个函数接收req、res两个入参。</p>\n<ol start=\"4\">\n<li>接下来我们再看一下这个<code>this.callback()</code>里的callback方法是啥样的：</li>\n</ol>\n<p><a target=\"_blank\" rel=\"noopener noreferrer\" href=\"https://camo.githubusercontent.com/176b92d3298a6bacc37390ecf7b6caf9d0b2d2e2/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323031392f706e672f3637363630302f313537373735373730373437342d36643163323563642d356666662d343133342d616138352d6662313365326264626432382e706e6723616c69676e3d6c65667426646973706c61793d696e6c696e65266865696768743d323631266e616d653d696d6167652e706e67266f726967696e4865696768743d323631266f726967696e57696474683d3632362673697a653d3333393435267374617475733d646f6e65267374796c653d6e6f6e652677696474683d363236\"><img src=\"https://camo.githubusercontent.com/176b92d3298a6bacc37390ecf7b6caf9d0b2d2e2/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323031392f706e672f3637363630302f313537373735373730373437342d36643163323563642d356666662d343133342d616138352d6662313365326264626432382e706e6723616c69676e3d6c65667426646973706c61793d696e6c696e65266865696768743d323631266e616d653d696d6167652e706e67266f726967696e4865696768743d323631266f726967696e57696474683d3632362673697a653d3333393435267374617475733d646f6e65267374796c653d6e6f6e652677696474683d363236\" alt=\"image.png\" data-canonical-src=\"https://cdn.nlark.com/yuque/0/2019/png/676600/1577757707474-6d1c25cd-5fff-4134-aa85-fb13e2bdbd28.png#align=left&display=inline&height=261&name=image.png&originHeight=261&originWidth=626&size=33945&status=done&style=none&width=626\" style=\"max-width:100%;\"></a><br>\ncallback方法内的第一句fn = compose(this.middleware)，这个this.middleware是我们在Application类中的constructor就定义了，是一个数组，这里实际上存储的就是我们举的栗子中的app.use（）的入参方法，也就是我们Koa的中间件。这个compose方法很重要，主要是控制我们的中间件的执行，下文讲中间件的执行机制会仔细说说这个compose。然后看这个函数返回，果然和我们推断的一样，这个callback方法最终返回的是一个handleRequest方法，接收req，res两个参数。handleRequest方法中，第一句this.createContext方法实际上就是对我们req、res对象的封装：<br>\n<a target=\"_blank\" rel=\"noopener noreferrer\" href=\"https://camo.githubusercontent.com/37944de2d69671d2a30bd0bc2eb358af36bfc485/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323031392f706e672f3637363630302f313537373737363139313833332d31343139653834642d636633662d346164362d393437652d6661653535333534666636392e706e6723616c69676e3d6c65667426646973706c61793d696e6c696e65266865696768743d333034266e616d653d696d6167652e706e67266f726967696e4865696768743d333034266f726967696e57696474683d3633342673697a653d3535303632267374617475733d646f6e65267374796c653d6e6f6e652677696474683d363334\"><img src=\"https://camo.githubusercontent.com/37944de2d69671d2a30bd0bc2eb358af36bfc485/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323031392f706e672f3637363630302f313537373737363139313833332d31343139653834642d636633662d346164362d393437652d6661653535333534666636392e706e6723616c69676e3d6c65667426646973706c61793d696e6c696e65266865696768743d333034266e616d653d696d6167652e706e67266f726967696e4865696768743d333034266f726967696e57696474683d3633342673697a653d3535303632267374617475733d646f6e65267374796c653d6e6f6e652677696474683d363334\" alt=\"image.png\" data-canonical-src=\"https://cdn.nlark.com/yuque/0/2019/png/676600/1577776191833-1419e84d-cf3f-4ad6-947e-fae55354ff69.png#align=left&display=inline&height=304&name=image.png&originHeight=304&originWidth=634&size=55062&status=done&style=none&width=634\" style=\"max-width:100%;\"></a><br>\n通过createContext 创建了我们ctx对象。这个callback方法返回的handleRequest方法第二句是返回了Application类上的handleRequest方法的执行结果（注意这里有“重名”的方法，注意区分），方法如下：<br>\n<a target=\"_blank\" rel=\"noopener noreferrer\" href=\"https://camo.githubusercontent.com/3aa0e9f882243e7b67072a57fe98a88a7745e983/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323031392f706e672f3637363630302f313537373737373336363239332d66646566653063612d383436362d346565312d393263622d6330343935326263303330612e706e6723616c69676e3d6c65667426646973706c61793d696e6c696e65266865696768743d313935266e616d653d696d6167652e706e67266f726967696e4865696768743d313935266f726967696e57696474683d3634332673697a653d3339363533267374617475733d646f6e65267374796c653d6e6f6e652677696474683d363433\"><img src=\"https://camo.githubusercontent.com/3aa0e9f882243e7b67072a57fe98a88a7745e983/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323031392f706e672f3637363630302f313537373737373336363239332d66646566653063612d383436362d346565312d393263622d6330343935326263303330612e706e6723616c69676e3d6c65667426646973706c61793d696e6c696e65266865696768743d313935266e616d653d696d6167652e706e67266f726967696e4865696768743d313935266f726967696e57696474683d3634332673697a653d3339363533267374617475733d646f6e65267374796c653d6e6f6e652677696474683d363433\" alt=\"image.png\" data-canonical-src=\"https://cdn.nlark.com/yuque/0/2019/png/676600/1577777366293-fdefe0ca-8466-4ee1-92cb-c04952bc030a.png#align=left&display=inline&height=195&name=image.png&originHeight=195&originWidth=643&size=39653&status=done&style=none&width=643\" style=\"max-width:100%;\"></a></p>\n<p>这个方法接收两个参数: 我们的compose的返回结果fn、ctx对象，主要是对我们请求的处理以及错误的统一捕获以及处理。</p>\n<h3>3. 执行一下我们的栗子：扒一扒中间件的执行机制</h3>\n<p>Koa的中间件执行机制有个形象的称呼-洋葱圈模型。我们先执行栗子代码，看看输出的结果到底是什么？<br>\n    <a target=\"_blank\" rel=\"noopener noreferrer\" href=\"https://camo.githubusercontent.com/44ca564a6bfb6b968e69413974297c386450292c/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323031392f706e672f3637363630302f313537373737383235323837332d33306264613436642d616632382d343264612d383137632d6536643532376561346539652e706e6723616c69676e3d6c65667426646973706c61793d696e6c696e65266865696768743d313036266e616d653d696d6167652e706e67266f726967696e4865696768743d313036266f726967696e57696474683d3239392673697a653d34353234267374617475733d646f6e65267374796c653d6e6f6e652677696474683d323939\"><img src=\"https://camo.githubusercontent.com/44ca564a6bfb6b968e69413974297c386450292c/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323031392f706e672f3637363630302f313537373737383235323837332d33306264613436642d616632382d343264612d383137632d6536643532376561346539652e706e6723616c69676e3d6c65667426646973706c61793d696e6c696e65266865696768743d313036266e616d653d696d6167652e706e67266f726967696e4865696768743d313036266f726967696e57696474683d3239392673697a653d34353234267374617475733d646f6e65267374796c653d6e6f6e652677696474683d323939\" alt=\"image.png\" data-canonical-src=\"https://cdn.nlark.com/yuque/0/2019/png/676600/1577778252873-30bda46d-af28-42da-817c-e6d527ea4e9e.png#align=left&display=inline&height=106&name=image.png&originHeight=106&originWidth=299&size=4524&status=done&style=none&width=299\" style=\"max-width:100%;\"></a></p>\n<h5>从use方法说起</h5>\n<p><a target=\"_blank\" rel=\"noopener noreferrer\" href=\"https://camo.githubusercontent.com/5e2a08feb193b97fa1f13ee462777b9dc97649b8/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323031392f706e672f3637363630302f313537373737383335363433392d36383932616234662d346566382d346239632d623762652d6232653436316262383333372e706e6723616c69676e3d6c65667426646973706c61793d696e6c696e65266865696768743d323639266e616d653d696d6167652e706e67266f726967696e4865696768743d323639266f726967696e57696474683d3738372673697a653d3433393536267374617475733d646f6e65267374796c653d6e6f6e652677696474683d373837\"><img src=\"https://camo.githubusercontent.com/5e2a08feb193b97fa1f13ee462777b9dc97649b8/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323031392f706e672f3637363630302f313537373737383335363433392d36383932616234662d346566382d346239632d623762652d6232653436316262383333372e706e6723616c69676e3d6c65667426646973706c61793d696e6c696e65266865696768743d323639266e616d653d696d6167652e706e67266f726967696e4865696768743d323639266f726967696e57696474683d3738372673697a653d3433393536267374617475733d646f6e65267374796c653d6e6f6e652677696474683d373837\" alt=\"image.png\" data-canonical-src=\"https://cdn.nlark.com/yuque/0/2019/png/676600/1577778356439-6892ab4f-4ef8-4b9c-b7be-b2e461bb8337.png#align=left&display=inline&height=269&name=image.png&originHeight=269&originWidth=787&size=43956&status=done&style=none&width=787\" style=\"max-width:100%;\"></a><br>\napp.use实际上就是调用了Applcation类下面的use方法，这个方法主要是先判断入参形式是否是一个函数等（参数校验），如果入参是一个generator函数，这也就是koa1中的写法，在koa2中需要koa-convert去转换一下。然后将我们入参传入的中间件函数push到this.middleware数组中。<br>\n再回到上文提到的callback函数，我们的中间件执行机制的核心就是compose(this.middleware),下面我们来分析一下compose函数的源码：<br>\n<a target=\"_blank\" rel=\"noopener noreferrer\" href=\"https://camo.githubusercontent.com/8f9c713e436d0a88c29b050490e83b5787fe80a3/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323031392f706e672f3637363630302f313537373738333238303038352d37373063393937642d623361312d346139332d613238612d3131343036303234376561662e706e6723616c69676e3d6c65667426646973706c61793d696e6c696e65266865696768743d363432266e616d653d696d6167652e706e67266f726967696e4865696768743d363432266f726967696e57696474683d3839322673697a653d3931323330267374617475733d646f6e65267374796c653d6e6f6e652677696474683d383932\"><img src=\"https://camo.githubusercontent.com/8f9c713e436d0a88c29b050490e83b5787fe80a3/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323031392f706e672f3637363630302f313537373738333238303038352d37373063393937642d623361312d346139332d613238612d3131343036303234376561662e706e6723616c69676e3d6c65667426646973706c61793d696e6c696e65266865696768743d363432266e616d653d696d6167652e706e67266f726967696e4865696768743d363432266f726967696e57696474683d3839322673697a653d3931323330267374617475733d646f6e65267374796c653d6e6f6e652677696474683d383932\" alt=\"image.png\" data-canonical-src=\"https://cdn.nlark.com/yuque/0/2019/png/676600/1577783280085-770c997d-b3a1-4a93-a28a-114060247eaf.png#align=left&display=inline&height=642&name=image.png&originHeight=642&originWidth=892&size=91230&status=done&style=none&width=892\" style=\"max-width:100%;\"></a></p>\n<ol>\n<li>先校验我们middleware的参数正确性，是否是数组，数组项是否为函数；</li>\n<li>compose函数实际上是返回一个function，这个返回的function，在上面也提及，最终是传入到handleRequest方法中然后传入ctx参数：fnMiddleware(context)。</li>\n<li>再回到我们的compose中return的这个function，接收两个参数：第一个就是我们handleRequest方法传入的ctx对象，第二个next呢，实际上是传入的一个方法，这个方法是在所有middleware执行完毕后，最后执行处理的函数。这个function核心就是递归执行我们的middleware。要理解这段代码，先要理解<code>Promise.reslove()</code>。</li>\n</ol>\n<div class=\"highlight highlight-source-js\"><pre><span class=\"pl-c\"><span class=\"pl-c\">//</span> Promise.reslove返回一个fulfillled状态的promise对象</span>\n<span class=\"pl-c\"><span class=\"pl-c\">//</span> 可以看成new Promise()的快捷方式</span>\n\n<span class=\"pl-c1\">Promise</span>.<span class=\"pl-en\">reslove</span>(<span class=\"pl-en\">fn</span>(context, <span class=\"pl-smi\">dispatch</span>.<span class=\"pl-en\">bind</span>(<span class=\"pl-c1\">null</span>, i<span class=\"pl-k\">+</span><span class=\"pl-c1\">1</span>)))；\n<span class=\"pl-c\"><span class=\"pl-c\">//</span> 实际上是等于</span>\n<span class=\"pl-k\">new</span> <span class=\"pl-en\">Promise</span>((<span class=\"pl-smi\">relove</span>, <span class=\"pl-smi\">reject</span>) <span class=\"pl-k\">=></span> {\n  <span class=\"pl-en\">reslove</span>(<span class=\"pl-en\">fn</span>(context, <span class=\"pl-smi\">dispatch</span>.<span class=\"pl-en\">bind</span>(<span class=\"pl-c1\">null</span>, i<span class=\"pl-k\">+</span><span class=\"pl-c1\">1</span>)));\n})</pre></div>\n<ol start=\"4\">\n<li>仔细阅读这个function, 它是先定义了一个index（利用我们的闭包每次执行一次dispatch方法去改变index），执行了dispatch(0),这个dispatch方法就是我们执行机制的实现，dispatch函数里面如果没有执行到最后一个middleware，就返回了<code>Promise.reslove(fn(context, dispatch.bind(null, i + 1)))</code>, 这个<code>fn(context, dispatch.bind(null, i + 1))</code>也就是执行我们通过<code>app.use</code>加入的middleware函数，middleware函数统一接收两个参数一个是context，一个是next：下一个middleware函数，这样可以看出来如果我们koa中某个中间件没有执行next方法，那么之后加入的中间件是不会执行的。这也就形成了我们的<code>洋葱圈模型</code>。</li>\n</ol>\n<div class=\"highlight highlight-source-js\"><pre><span class=\"pl-c\"><span class=\"pl-c\">//</span> 核心方法：递归调用我们middlewares, 基于Promise进行异步流程控制；</span>\n<span class=\"pl-c\"><span class=\"pl-c\">//</span> Promise.resolve()返回的是一个thenable对象；</span>\n<span class=\"pl-c\"><span class=\"pl-c\">//</span> 所以我们koa2中中间件都基于async函数，await等待下个中间件方法的执行；</span>\n<span class=\"pl-k\">return</span> <span class=\"pl-k\">function</span> (<span class=\"pl-smi\">context</span>, <span class=\"pl-smi\">next</span>) {\n    <span class=\"pl-c\"><span class=\"pl-c\">//</span> last called middleware #</span>\n    <span class=\"pl-k\">let</span> index <span class=\"pl-k\">=</span> <span class=\"pl-k\">-</span><span class=\"pl-c1\">1</span>\n    <span class=\"pl-k\">return</span> <span class=\"pl-en\">dispatch</span>(<span class=\"pl-c1\">0</span>)\n    <span class=\"pl-k\">function</span> <span class=\"pl-en\">dispatch</span> (<span class=\"pl-smi\">i</span>) {\n      <span class=\"pl-k\">if</span> (i <span class=\"pl-k\"><=</span> index) <span class=\"pl-k\">return</span> <span class=\"pl-c1\">Promise</span>.<span class=\"pl-c1\">reject</span>(<span class=\"pl-k\">new</span> <span class=\"pl-en\">Error</span>(<span class=\"pl-s\"><span class=\"pl-pds\">'</span>next() called multiple times<span class=\"pl-pds\">'</span></span>))\n      index <span class=\"pl-k\">=</span> i\n      <span class=\"pl-k\">let</span> fn <span class=\"pl-k\">=</span> middleware[i]\n      <span class=\"pl-k\">if</span> (i <span class=\"pl-k\">===</span> <span class=\"pl-smi\">middleware</span>.<span class=\"pl-c1\">length</span>) fn <span class=\"pl-k\">=</span> next\n      <span class=\"pl-k\">if</span> (<span class=\"pl-k\">!</span>fn) <span class=\"pl-k\">return</span> <span class=\"pl-c1\">Promise</span>.<span class=\"pl-c1\">resolve</span>()\n      <span class=\"pl-k\">try</span> {\n        <span class=\"pl-k\">return</span> <span class=\"pl-c1\">Promise</span>.<span class=\"pl-c1\">resolve</span>(<span class=\"pl-en\">fn</span>(context, <span class=\"pl-smi\">dispatch</span>.<span class=\"pl-en\">bind</span>(<span class=\"pl-c1\">null</span>, i <span class=\"pl-k\">+</span> <span class=\"pl-c1\">1</span>)));\n      } <span class=\"pl-k\">catch</span> (err) {\n        <span class=\"pl-k\">return</span> <span class=\"pl-c1\">Promise</span>.<span class=\"pl-c1\">reject</span>(err)\n      }\n    }\n  }</pre></div>\n<h2>四、总结</h2>\n<ol>\n<li>Koa这个框架是小而精美的，它的源码是也非常少，只有一千多行。中间件的执行机制主要是读懂这个koa-compose的代码，多个中间件会形成一个<code>先进后出</code>的栈结构，当前中间件掌握下一个中间件的执行权。</li>\n<li>Koa本身的功能可能是满足不了我们日常开发的需求的，我们可以通过许多的第三方的包，也可以自定义中间件来辅助我们的开发。（了解了中间件机制，自定义一个中间件就非常容易了）</li>\n<li><code>Koa1</code>借助<code>co</code> and <code>generator</code>管理我们的中间件，<code>Koa2</code>借助<code>async await</code>（async函数返回的是<code>Promise</code>对象）管理我们的中间件。</li>\n</ol>\n<h3>五、参考文档</h3>\n<ol>\n<li><a href=\"https://zhuanlan.zhihu.com/p/33316664\" rel=\"nofollow\">Koa2 还有多久取代 Express</a></li>\n<li><a href=\"https://blog.csdn.net/zramals/article/details/80653715\" rel=\"nofollow\">Koa vs Express && Koa1 vs Koa2</a></li>\n</ol>\n      </td>\n    </tr>\n  </tbody>\n</table>",
      "title": "Koa源码分析（中间件执行机制、Koa2与Koa1比较)",
      "time": "2020-01-01"
    }
  ]
}